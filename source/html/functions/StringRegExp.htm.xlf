<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions">
<file original="html/functions/StringRegExp.htm" source-language="en" target-language="fr" datatype="html">
<body>
<trans-unit id="1">
<source xml:lang="en">Check if a string fits a given regular expression pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Check if a string fits a given regular expression pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Check if a string fits a given regular expression pattern.</mrk></target>
<note>Function StringRegExp</note>
</trans-unit>
<trans-unit id="2">
<source xml:lang="en">Parameters</source>
<seg-source><mrk mid="0" mtype="seg">Parameters</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Parameters</mrk></target>
</trans-unit>
<trans-unit id="3">
<source xml:lang="en">The subject string to check</source>
<seg-source><mrk mid="0" mtype="seg">The subject string to check</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The subject string to check</mrk></target>
<note>test</note>
</trans-unit>
<trans-unit id="4">
<source xml:lang="en">The regular expression to match.</source>
<seg-source><mrk mid="0" mtype="seg">The regular expression to match.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The regular expression to match.</mrk></target>
<note>pattern</note>
</trans-unit>
<trans-unit id="5">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept> A number to indicate how the function behaves. See below for details. The default is 0.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">A number to indicate how the function behaves.</mrk> <mrk mid="2" mtype="seg">See below for details.</mrk> <mrk mid="3" mtype="seg">The default is 0.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">A number to indicate how the function behaves.</mrk> <mrk mid="2" mtype="seg">See below for details.</mrk> <mrk mid="3" mtype="seg">The default is 0.</mrk></target>
<note>flag</note>
</trans-unit>
<trans-unit id="6">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept> The string position to start the match (starts at 1). The default is 1.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">The string position to start the match (starts at 1).</mrk> <mrk mid="2" mtype="seg">The default is 1.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[optional]<ept id="1">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">The string position to start the match (starts at 1).</mrk> <mrk mid="2" mtype="seg">The default is 1.</mrk></target>
<note>offset</note>
</trans-unit>
<trans-unit id="7">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Values<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Values<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Values<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="8">
<source xml:lang="en">Returns 1 (match) or 0 (no match). (Default).</source>
<seg-source><mrk mid="0" mtype="seg">Returns 1 (match) or 0 (no match).</mrk> <mrk mid="1" mtype="seg">(Default).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Returns 1 (match) or 0 (no match).</mrk> <mrk mid="1" mtype="seg">(Default).</mrk></target>
<note>$STR_REGEXPMATCH (0)</note>
</trans-unit>
<trans-unit id="9">
<source xml:lang="en">Return array of matches.</source>
<seg-source><mrk mid="0" mtype="seg">Return array of matches.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Return array of matches.</mrk></target>
<note>$STR_REGEXPARRAYMATCH (1)</note>
</trans-unit>
<trans-unit id="10">
<source xml:lang="en">Return array of matches including the full match (Perl / PHP style).</source>
<seg-source><mrk mid="0" mtype="seg">Return array of matches including the full match (Perl / PHP style).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Return array of matches including the full match (Perl / PHP style).</mrk></target>
<note>$STR_REGEXPARRAYFULLMATCH (2)</note>
</trans-unit>
<trans-unit id="11">
<source xml:lang="en">Return array of global matches.</source>
<seg-source><mrk mid="0" mtype="seg">Return array of global matches.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Return array of global matches.</mrk></target>
<note>$STR_REGEXPARRAYGLOBALMATCH (3)</note>
</trans-unit>
<trans-unit id="12">
<source xml:lang="en">Return an array of arrays containing global matches including the full match (Perl / PHP style).</source>
<seg-source><mrk mid="0" mtype="seg">Return an array of arrays containing global matches including the full match (Perl / PHP style).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Return an array of arrays containing global matches including the full match (Perl / PHP style).</mrk></target>
<note>$STR_REGEXPARRAYGLOBALFULLMATCH (4)</note>
</trans-unit>
<trans-unit id="13">
<source xml:lang="en">Constants are defined in StringConstants.au3.</source>
<seg-source><mrk mid="0" mtype="seg">Constants are defined in StringConstants.au3.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Constants are defined in StringConstants.au3.</mrk></target>
</trans-unit>
<trans-unit id="14">
<source xml:lang="en">Return Value</source>
<seg-source><mrk mid="0" mtype="seg">Return Value</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Return Value</mrk></target>
</trans-unit>
<trans-unit id="15">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPMATCH (0) :<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPMATCH (0) :<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPMATCH (0) :<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="16">
<source xml:lang="en">@error:</source>
<seg-source><mrk mid="0" mtype="seg">@error:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">@error:</mrk></target>
</trans-unit>
<trans-unit id="17">
<source xml:lang="en">Meaning</source>
<seg-source><mrk mid="0" mtype="seg">Meaning</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Meaning</mrk></target>
<note>@error:</note>
</trans-unit>
<trans-unit id="18">
<source xml:lang="en">2:</source>
<seg-source><mrk mid="0" mtype="seg">2:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">2:</mrk></target>
</trans-unit>
<trans-unit id="19">
<source xml:lang="en">Bad pattern. @extended = offset of error in pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Bad pattern.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Bad pattern.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></target>
<note>2:</note>
</trans-unit>
<trans-unit id="20">
<source xml:lang="en"> <bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYMATCH (1) or $STR_REGEXPARRAYFULLMATCH (2) :<ept id="1">&lt;/em></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYMATCH (1) or $STR_REGEXPARRAYFULLMATCH (2) :<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYMATCH (1) or $STR_REGEXPARRAYFULLMATCH (2) :<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="21">
<source xml:lang="en">@error:</source>
<seg-source><mrk mid="0" mtype="seg">@error:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">@error:</mrk></target>
</trans-unit>
<trans-unit id="22">
<source xml:lang="en">Meaning</source>
<seg-source><mrk mid="0" mtype="seg">Meaning</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Meaning</mrk></target>
<note>@error:</note>
</trans-unit>
<trans-unit id="23">
<source xml:lang="en">0:</source>
<seg-source><mrk mid="0" mtype="seg">0:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0:</mrk></target>
</trans-unit>
<trans-unit id="24">
<source xml:lang="en">Array is valid. Check @extended for next offset</source>
<seg-source><mrk mid="0" mtype="seg">Array is valid.</mrk> <mrk mid="1" mtype="seg">Check @extended for next offset</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Array is valid.</mrk> <mrk mid="1" mtype="seg">Check @extended for next offset</mrk></target>
<note>0:</note>
</trans-unit>
<trans-unit id="25">
<source xml:lang="en">1:</source>
<seg-source><mrk mid="0" mtype="seg">1:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">1:</mrk></target>
</trans-unit>
<trans-unit id="26">
<source xml:lang="en">Array is invalid. No matches.</source>
<seg-source><mrk mid="0" mtype="seg">Array is invalid.</mrk> <mrk mid="1" mtype="seg">No matches.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Array is invalid.</mrk> <mrk mid="1" mtype="seg">No matches.</mrk></target>
<note>1:</note>
</trans-unit>
<trans-unit id="27">
<source xml:lang="en">2:</source>
<seg-source><mrk mid="0" mtype="seg">2:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">2:</mrk></target>
</trans-unit>
<trans-unit id="28">
<source xml:lang="en">Bad pattern, array is invalid. @extended = offset of error in pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Bad pattern, array is invalid.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Bad pattern, array is invalid.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></target>
<note>2:</note>
</trans-unit>
<trans-unit id="29">
<source xml:lang="en"> <bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYGLOBALMATCH (3) or $STR_REGEXPARRAYGLOBALFULLMATCH (4) :<ept id="1">&lt;/em></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYGLOBALMATCH (3) or $STR_REGEXPARRAYGLOBALFULLMATCH (4) :<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Flag = $STR_REGEXPARRAYGLOBALMATCH (3) or $STR_REGEXPARRAYGLOBALFULLMATCH (4) :<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="30">
<source xml:lang="en">@error:</source>
<seg-source><mrk mid="0" mtype="seg">@error:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">@error:</mrk></target>
</trans-unit>
<trans-unit id="31">
<source xml:lang="en">Meaning</source>
<seg-source><mrk mid="0" mtype="seg">Meaning</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Meaning</mrk></target>
<note>@error:</note>
</trans-unit>
<trans-unit id="32">
<source xml:lang="en">0:</source>
<seg-source><mrk mid="0" mtype="seg">0:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0:</mrk></target>
</trans-unit>
<trans-unit id="33">
<source xml:lang="en">Array is valid.</source>
<seg-source><mrk mid="0" mtype="seg">Array is valid.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Array is valid.</mrk></target>
<note>0:</note>
</trans-unit>
<trans-unit id="34">
<source xml:lang="en">1:</source>
<seg-source><mrk mid="0" mtype="seg">1:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">1:</mrk></target>
</trans-unit>
<trans-unit id="35">
<source xml:lang="en">Array is invalid. No matches.</source>
<seg-source><mrk mid="0" mtype="seg">Array is invalid.</mrk> <mrk mid="1" mtype="seg">No matches.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Array is invalid.</mrk> <mrk mid="1" mtype="seg">No matches.</mrk></target>
<note>1:</note>
</trans-unit>
<trans-unit id="36">
<source xml:lang="en">2:</source>
<seg-source><mrk mid="0" mtype="seg">2:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">2:</mrk></target>
</trans-unit>
<trans-unit id="37">
<source xml:lang="en">Bad pattern, array is invalid. @extended = offset of error in pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Bad pattern, array is invalid.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Bad pattern, array is invalid.</mrk> <mrk mid="1" mtype="seg">@extended = offset of error in pattern.</mrk></target>
<note>2:</note>
</trans-unit>
<trans-unit id="38">
<source xml:lang="en">Remarks</source>
<seg-source><mrk mid="0" mtype="seg">Remarks</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Remarks</mrk></target>
</trans-unit>
<trans-unit id="39">
<source xml:lang="en">The flag parameter can have one of 5 values ($STR_REGEXPMATCH (0) through $STR_REGEXPARRAYGLOBALFULLMATCH (4)).</source>
<seg-source><mrk mid="0" mtype="seg">The flag parameter can have one of 5 values ($STR_REGEXPMATCH (0) through $STR_REGEXPARRAYGLOBALFULLMATCH (4)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The flag parameter can have one of 5 values ($STR_REGEXPMATCH (0) through $STR_REGEXPARRAYGLOBALFULLMATCH (4)).</mrk></target>
</trans-unit>
<trans-unit id="40">
<source xml:lang="en">$STR_REGEXPMATCH (0)</source>
<seg-source><mrk mid="0" mtype="seg">$STR_REGEXPMATCH (0)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">$STR_REGEXPMATCH (0)</mrk></target>
</trans-unit>
<trans-unit id="41">
<source xml:lang="en">returns 1 (true) or 0 (false) if the pattern was found or not.</source>
<seg-source><mrk mid="0" mtype="seg">returns 1 (true) or 0 (false) if the pattern was found or not.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">returns 1 (true) or 0 (false) if the pattern was found or not.</mrk></target>
<note>$STR_REGEXPMATCH (0)</note>
</trans-unit>
<trans-unit id="42">
<source xml:lang="en">$STR_REGEXPARRAYMATCH (1)</source>
<seg-source><mrk mid="0" mtype="seg">$STR_REGEXPARRAYMATCH (1)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">$STR_REGEXPARRAYMATCH (1)</mrk></target>
</trans-unit>
<trans-unit id="43">
<source xml:lang="en"> $STR_REGEXPARRAYFULLMATCH (2)</source>
<seg-source> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYFULLMATCH (2)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYFULLMATCH (2)</mrk></target>
</trans-unit>
<trans-unit id="44">
<source xml:lang="en">find the first match and return captured groups in an array; when the pattern has no capturing groups, the first match is returned in the array.</source>
<seg-source><mrk mid="0" mtype="seg">find the first match and return captured groups in an array; when the pattern has no capturing groups, the first match is returned in the array.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">find the first match and return captured groups in an array; when the pattern has no capturing groups, the first match is returned in the array.</mrk></target>
<note>$STR_REGEXPARRAYMATCH (1)</note>
</trans-unit>
<trans-unit id="45">
<source xml:lang="en">$STR_REGEXPARRAYGLOBALMATCH (3)</source>
<seg-source><mrk mid="0" mtype="seg">$STR_REGEXPARRAYGLOBALMATCH (3)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">$STR_REGEXPARRAYGLOBALMATCH (3)</mrk></target>
</trans-unit>
<trans-unit id="46">
<source xml:lang="en"> $STR_REGEXPARRAYGLOBALFULLMATCH (4)</source>
<seg-source> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYGLOBALFULLMATCH (4)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYGLOBALFULLMATCH (4)</mrk></target>
</trans-unit>
<trans-unit id="47">
<source xml:lang="en">fill the array with all matching instances.</source>
<seg-source><mrk mid="0" mtype="seg">fill the array with all matching instances.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">fill the array with all matching instances.</mrk></target>
<note>$STR_REGEXPARRAYGLOBALMATCH (3)</note>
</trans-unit>
<trans-unit id="48">
<source xml:lang="en"> $STR_REGEXPARRAYFULLMATCH (2) and $STR_REGEXPARRAYGLOBALFULLMATCH (4) include the full matching text as the first element of the return array, not just the captured groups as with flag $STR_REGEXPARRAYMATCH (1) and $STR_REGEXPARRAYGLOBALMATCH (3).</source>
<seg-source> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYFULLMATCH (2) and $STR_REGEXPARRAYGLOBALFULLMATCH (4) include the full matching text as the first element of the return array, not just the captured groups as with flag $STR_REGEXPARRAYMATCH (1) and $STR_REGEXPARRAYGLOBALMATCH (3).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">$STR_REGEXPARRAYFULLMATCH (2) and $STR_REGEXPARRAYGLOBALFULLMATCH (4) include the full matching text as the first element of the return array, not just the captured groups as with flag $STR_REGEXPARRAYMATCH (1) and $STR_REGEXPARRAYGLOBALMATCH (3).</mrk></target>
</trans-unit>
<trans-unit id="49">
<source xml:lang="en"> Regular expression notation is a compact way of specifying a pattern for subject strings that can be searched and from which specific parts can be extracted by <bpt id="1" ctype="x-a">&lt;a href="StringRegExp.htm"></bpt>StringRegExp()<ept id="1">&lt;/a></ept> or replaced when using <bpt id="2" ctype="x-a">&lt;a href="StringRegExpReplace.htm"></bpt>StringRegExpReplace()<ept id="2">&lt;/a></ept>.</source>
<seg-source> <mrk mid="0" mtype="seg">Regular expression notation is a compact way of specifying a pattern for subject strings that can be searched and from which specific parts can be extracted by <bpt id="1" ctype="x-a">&lt;a href="StringRegExp.htm"></bpt>StringRegExp()<ept id="1">&lt;/a></ept> or replaced when using <bpt id="2" ctype="x-a">&lt;a href="StringRegExpReplace.htm"></bpt>StringRegExpReplace()<ept id="2">&lt;/a></ept>.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Regular expression notation is a compact way of specifying a pattern for subject strings that can be searched and from which specific parts can be extracted by <bpt id="1" ctype="x-a">&lt;a href="StringRegExp.htm"></bpt>StringRegExp()<ept id="1">&lt;/a></ept> or replaced when using <bpt id="2" ctype="x-a">&lt;a href="StringRegExpReplace.htm"></bpt>StringRegExpReplace()<ept id="2">&lt;/a></ept>.</mrk></target>
</trans-unit>
<trans-unit id="50">
<source xml:lang="en"> More precisely, the regular expression engine tries to match a pattern (a kind of programmatic format) with a subject string, both from left to right. Should a mismatch occur, the engines tries to backtrack (return to successively previous states) as much as needed, expecting that the rest of the pattern will match as well.</source>
<seg-source> <mrk mid="0" mtype="seg">More precisely, the regular expression engine tries to match a pattern (a kind of programmatic format) with a subject string, both from left to right.</mrk> <mrk mid="1" mtype="seg">Should a mismatch occur, the engines tries to backtrack (return to successively previous states) as much as needed, expecting that the rest of the pattern will match as well.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">More precisely, the regular expression engine tries to match a pattern (a kind of programmatic format) with a subject string, both from left to right.</mrk> <mrk mid="1" mtype="seg">Should a mismatch occur, the engines tries to backtrack (return to successively previous states) as much as needed, expecting that the rest of the pattern will match as well.</mrk></target>
</trans-unit>
<trans-unit id="51">
<source xml:lang="en"> Backtracking is a fundamental feature of regular expression engines and one that every novice programmer already understand and uses daily. It is like leaving a specific mark on every fork in the road and going back to the last untried path when the choosen path turns out to be a dead end: you backtrack as needed until you find the right point (match success) or explore every path without reaching your goal (match failure). Searching a given filename with optional wildcards inside a directory tree is no different.</source>
<seg-source> <mrk mid="0" mtype="seg">Backtracking is a fundamental feature of regular expression engines and one that every novice programmer already understand and uses daily.</mrk> <mrk mid="1" mtype="seg">It is like leaving a specific mark on every fork in the road and going back to the last untried path when the choosen path turns out to be a dead end: you backtrack as needed until you find the right point (match success) or explore every path without reaching your goal (match failure).</mrk> <mrk mid="2" mtype="seg">Searching a given filename with optional wildcards inside a directory tree is no different.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Backtracking is a fundamental feature of regular expression engines and one that every novice programmer already understand and uses daily.</mrk> <mrk mid="1" mtype="seg">It is like leaving a specific mark on every fork in the road and going back to the last untried path when the choosen path turns out to be a dead end: you backtrack as needed until you find the right point (match success) or explore every path without reaching your goal (match failure).</mrk> <mrk mid="2" mtype="seg">Searching a given filename with optional wildcards inside a directory tree is no different.</mrk></target>
</trans-unit>
<trans-unit id="52">
<source xml:lang="en"> AutoIt uses the PCRE engine. PCRE means "Perl-Compatible Regular Expressions" and is the most comprehensive open-source engine available. This implementation includes Unicode Category Properties (UCP) support, which allows fine-grain processing of most human languages.</source>
<seg-source> <mrk mid="0" mtype="seg">AutoIt uses the PCRE engine.</mrk> <mrk mid="1" mtype="seg">PCRE means "Perl-Compatible Regular Expressions" and is the most comprehensive open-source engine available.</mrk> <mrk mid="2" mtype="seg">This implementation includes Unicode Category Properties (UCP) support, which allows fine-grain processing of most human languages.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">AutoIt uses the PCRE engine.</mrk> <mrk mid="1" mtype="seg">PCRE means "Perl-Compatible Regular Expressions" and is the most comprehensive open-source engine available.</mrk> <mrk mid="2" mtype="seg">This implementation includes Unicode Category Properties (UCP) support, which allows fine-grain processing of most human languages.</mrk></target>
</trans-unit>
<trans-unit id="53">
<source xml:lang="en"> However to maintain compatibility with previous versions and keep matching speed at its best, <bpt id="1" ctype="x-strong">&lt;strong></bpt>the UCP support is not enabled by default<ept id="1">&lt;/strong></ept>. You can enable it by prepending the string <bpt id="1" ctype="x-strong">&lt;strong></bpt>(*UCP)<ept id="1">&lt;/strong></ept> at the very start of your pattern. When enabled, the UCP setting changes the extend of a number of regular expression elements, as documented below where applicable.</source>
<seg-source> <mrk mid="0" mtype="seg">However to maintain compatibility with previous versions and keep matching speed at its best, <bpt id="1" ctype="x-strong">&lt;strong></bpt>the UCP support is not enabled by default<ept id="1">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">You can enable it by prepending the string <bpt id="1" ctype="x-strong">&lt;strong></bpt>(*UCP)<ept id="1">&lt;/strong></ept> at the very start of your pattern.</mrk> <mrk mid="2" mtype="seg">When enabled, the UCP setting changes the extend of a number of regular expression elements, as documented below where applicable.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">However to maintain compatibility with previous versions and keep matching speed at its best, <bpt id="1" ctype="x-strong">&lt;strong></bpt>the UCP support is not enabled by default<ept id="1">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">You can enable it by prepending the string <bpt id="1" ctype="x-strong">&lt;strong></bpt>(*UCP)<ept id="1">&lt;/strong></ept> at the very start of your pattern.</mrk> <mrk mid="2" mtype="seg">When enabled, the UCP setting changes the extend of a number of regular expression elements, as documented below where applicable.</mrk></target>
</trans-unit>
<trans-unit id="54">
<source xml:lang="en"> This page is only a summary for the most used pattern elements. For full in-depth discussion of regular expressions as implemented in AutoIt, refer to the <bpt id="1" ctype="x-strong">&lt;strong></bpt><bpt id="2" ctype="x-a">&lt;a href="http://www.autoitscript.com/autoit3/pcrepattern.html" target="_blank"></bpt>complete description of PCRE patterns<ept id="2">&lt;/a></ept><ept id="1">&lt;/strong></ept>.</source>
<seg-source> <mrk mid="0" mtype="seg">This page is only a summary for the most used pattern elements.</mrk> <mrk mid="1" mtype="seg">For full in-depth discussion of regular expressions as implemented in AutoIt, refer to the <bpt id="1" ctype="x-strong">&lt;strong></bpt><bpt id="2" ctype="x-a">&lt;a href="http://www.autoitscript.com/autoit3/pcrepattern.html" target="_blank"></bpt>complete description of PCRE patterns<ept id="2">&lt;/a></ept><ept id="1">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">This page is only a summary for the most used pattern elements.</mrk> <mrk mid="1" mtype="seg">For full in-depth discussion of regular expressions as implemented in AutoIt, refer to the <bpt id="1" ctype="x-strong">&lt;strong></bpt><bpt id="2" ctype="x-a">&lt;a href="http://www.autoitscript.com/autoit3/pcrepattern.html" target="_blank"></bpt>complete description of PCRE patterns<ept id="2">&lt;/a></ept><ept id="1">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="55">
<source xml:lang="en"> Unless you are already familiar with regular expressions you will probably need to read several parts of this summary more than once to grasp how they work and inter-relate.</source>
<seg-source> <mrk mid="0" mtype="seg">Unless you are already familiar with regular expressions you will probably need to read several parts of this summary more than once to grasp how they work and inter-relate.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Unless you are already familiar with regular expressions you will probably need to read several parts of this summary more than once to grasp how they work and inter-relate.</mrk></target>
</trans-unit>
<trans-unit id="56">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Caution<ept id="1">&lt;/strong></ept>: bad regular expressions can produce a quasi-infinite loop hogging the CPU, and can even cause a crash.</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Caution<ept id="1">&lt;/strong></ept>: bad regular expressions can produce a quasi-infinite loop hogging the CPU, and can even cause a crash.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Caution<ept id="1">&lt;/strong></ept>: bad regular expressions can produce a quasi-infinite loop hogging the CPU, and can even cause a crash.</mrk></target>
</trans-unit>
<trans-unit id="57">
<source xml:lang="en"><bpt id="1" ctype="x-u">&lt;u></bpt>Global settings<ept id="1">&lt;/u></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Global settings<ept id="1">&lt;/u></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Global settings<ept id="1">&lt;/u></ept></mrk></target>
</trans-unit>
<trans-unit id="58">
<source xml:lang="en"> These settings are only recognized at the start of the pattern and affect it globally.</source>
<seg-source> <mrk mid="0" mtype="seg">These settings are only recognized at the start of the pattern and affect it globally.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">These settings are only recognized at the start of the pattern and affect it globally.</mrk></target>
</trans-unit>
<trans-unit id="59">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Newline conventions<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Newline conventions<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Newline conventions<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="60">
<source xml:lang="en"> Newline sequences affect where the <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> anchors match and what <bpt id="3" ctype="x-strong">&lt;strong></bpt>\N<ept id="3">&lt;/strong></ept> and <bpt id="4" ctype="x-strong">&lt;strong></bpt>.<ept id="4">&lt;/strong></ept> do not match. By default the newline sequence is @CRLF as an unbreakable sequence or lone @CR or @LF.</source>
<seg-source> <mrk mid="0" mtype="seg">Newline sequences affect where the <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> anchors match and what <bpt id="3" ctype="x-strong">&lt;strong></bpt>\N<ept id="3">&lt;/strong></ept> and <bpt id="4" ctype="x-strong">&lt;strong></bpt>.<ept id="4">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">do not match.</mrk> <mrk mid="2" mtype="seg">By default the newline sequence is @CRLF as an unbreakable sequence or lone @CR or @LF.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Newline sequences affect where the <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> anchors match and what <bpt id="3" ctype="x-strong">&lt;strong></bpt>\N<ept id="3">&lt;/strong></ept> and <bpt id="4" ctype="x-strong">&lt;strong></bpt>.<ept id="4">&lt;/strong></ept></mrk> <mrk mid="1" mtype="seg">do not match.</mrk> <mrk mid="2" mtype="seg">By default the newline sequence is @CRLF as an unbreakable sequence or lone @CR or @LF.</mrk></target>
</trans-unit>
<trans-unit id="61">
<source xml:lang="en"> The default can be changed by prepending one of the following sequence at the start of a pattern. </source>
<seg-source> <mrk mid="0" mtype="seg">The default can be changed by prepending one of the following sequence at the start of a pattern.</mrk> </seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">The default can be changed by prepending one of the following sequence at the start of a pattern.</mrk> </target>
</trans-unit>
<trans-unit id="62">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CR)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CR)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CR)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="63">
<source xml:lang="en">Carriage return (@CR).</source>
<seg-source><mrk mid="0" mtype="seg">Carriage return (@CR).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Carriage return (@CR).</mrk></target>
</trans-unit>
<trans-unit id="64">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LF)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LF)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LF)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="65">
<source xml:lang="en">Line feed (@LF).</source>
<seg-source><mrk mid="0" mtype="seg">Line feed (@LF).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Line feed (@LF).</mrk></target>
</trans-unit>
<trans-unit id="66">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CRLF)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CRLF)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*CRLF)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="67">
<source xml:lang="en">Carriage return immediately followed by linefeed (@CRLF).</source>
<seg-source><mrk mid="0" mtype="seg">Carriage return immediately followed by linefeed (@CRLF).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Carriage return immediately followed by linefeed (@CRLF).</mrk></target>
</trans-unit>
<trans-unit id="68">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANYCRLF)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANYCRLF)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANYCRLF)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="69">
<source xml:lang="en">Any of @CRLF, @CR or @LF. This is the default newline convention.</source>
<seg-source><mrk mid="0" mtype="seg">Any of @CRLF, @CR or @LF.</mrk> <mrk mid="1" mtype="seg">This is the default newline convention.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Any of @CRLF, @CR or @LF.</mrk> <mrk mid="1" mtype="seg">This is the default newline convention.</mrk></target>
</trans-unit>
<trans-unit id="70">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANY)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANY)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ANY)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="71">
<source xml:lang="en">Any Unicode newline sequence: @CRLF, @LF, VT, FF, @CR or \x85.</source>
<seg-source><mrk mid="0" mtype="seg">Any Unicode newline sequence:</mrk> <mrk mid="1" mtype="seg">@CRLF, @LF, VT, FF, @CR or \x85.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Any Unicode newline sequence:</mrk> <mrk mid="1" mtype="seg">@CRLF, @LF, VT, FF, @CR or \x85.</mrk></target>
</trans-unit>
<trans-unit id="72">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>What \R matches<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>What \R matches<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>What \R matches<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="73">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_ANYCRLF)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_ANYCRLF)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_ANYCRLF)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="74">
<source xml:lang="en">By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches @CRLF, @CR or @LF only.</source>
<seg-source><mrk mid="0" mtype="seg">By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches @CRLF, @CR or @LF only.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches @CRLF, @CR or @LF only.</mrk></target>
</trans-unit>
<trans-unit id="75">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_UNICODE)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_UNICODE)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*BSR_UNICODE)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="76">
<source xml:lang="en">Changes <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> to match any Unicode newline sequence: @CRLF, @LF, VT, FF, @CR or \x85.</source>
<seg-source><mrk mid="0" mtype="seg">Changes <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> to match any Unicode newline sequence:</mrk> <mrk mid="1" mtype="seg">@CRLF, @LF, VT, FF, @CR or \x85.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Changes <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> to match any Unicode newline sequence:</mrk> <mrk mid="1" mtype="seg">@CRLF, @LF, VT, FF, @CR or \x85.</mrk></target>
</trans-unit>
<trans-unit id="77">
<source xml:lang="en"> PCRE patterns may contain options, which are enclosed in <it id="1" ctype="x-strong" pos="open">&lt;strong></it>(? )<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> sequences. Options can be grouped together: "(?imx)". Options following an hyphen are negated: "(?im-sx)".</source>
<seg-source> <mrk mid="0" mtype="seg">PCRE patterns may contain options, which are enclosed in <it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk> <mrk mid="1" mtype="seg">)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> sequences.</mrk> <mrk mid="2" mtype="seg">Options can be grouped together:</mrk> <mrk mid="3" mtype="seg">"(?imx)".</mrk> <mrk mid="4" mtype="seg">Options following an hyphen are negated:</mrk> <mrk mid="5" mtype="seg">"(?im-sx)".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">PCRE patterns may contain options, which are enclosed in <it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk> <mrk mid="1" mtype="seg">)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> sequences.</mrk> <mrk mid="2" mtype="seg">Options can be grouped together:</mrk> <mrk mid="3" mtype="seg">"(?imx)".</mrk> <mrk mid="4" mtype="seg">Options following an hyphen are negated:</mrk> <mrk mid="5" mtype="seg">"(?im-sx)".</mrk></target>
</trans-unit>
<trans-unit id="78">
<source xml:lang="en"> Options appearing outside a group affect the remaining of the pattern from that point onwards. Options appearing inside a group affect that group only. Options loose their special meaning inside a character class, where they are treated literally.</source>
<seg-source> <mrk mid="0" mtype="seg">Options appearing outside a group affect the remaining of the pattern from that point onwards.</mrk> <mrk mid="1" mtype="seg">Options appearing inside a group affect that group only.</mrk> <mrk mid="2" mtype="seg">Options loose their special meaning inside a character class, where they are treated literally.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Options appearing outside a group affect the remaining of the pattern from that point onwards.</mrk> <mrk mid="1" mtype="seg">Options appearing inside a group affect that group only.</mrk> <mrk mid="2" mtype="seg">Options loose their special meaning inside a character class, where they are treated literally.</mrk></target>
</trans-unit>
<trans-unit id="79">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?i)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?i)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?i)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="80">
<source xml:lang="en">Caseless: matching becomes case-insensitive from that point on. By default, matching is case-sensitive. When UCP is enabled casing applies to the entire Unicode plane 0, else applies by default to ASCII letters A-Z and a-z only.</source>
<seg-source><mrk mid="0" mtype="seg">Caseless: matching becomes case-insensitive from that point on.</mrk> <mrk mid="1" mtype="seg">By default, matching is case-sensitive.</mrk> <mrk mid="2" mtype="seg">When UCP is enabled casing applies to the entire Unicode plane 0, else applies by default to ASCII letters A-Z and a-z only.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Caseless: matching becomes case-insensitive from that point on.</mrk> <mrk mid="1" mtype="seg">By default, matching is case-sensitive.</mrk> <mrk mid="2" mtype="seg">When UCP is enabled casing applies to the entire Unicode plane 0, else applies by default to ASCII letters A-Z and a-z only.</mrk></target>
</trans-unit>
<trans-unit id="81">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="82">
<source xml:lang="en">Multiline: <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> match at newline sequences within data. By default, multiline is off.</source>
<seg-source><mrk mid="0" mtype="seg">Multiline:</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> match at newline sequences within data.</mrk> <mrk mid="2" mtype="seg">By default, multiline is off.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Multiline:</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>$<ept id="2">&lt;/strong></ept> match at newline sequences within data.</mrk> <mrk mid="2" mtype="seg">By default, multiline is off.</mrk></target>
</trans-unit>
<trans-unit id="83">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="84">
<source xml:lang="en">Single-line or <bpt id="1" ctype="x-em">&lt;em></bpt>DotAll<ept id="1">&lt;/em></ept>: <bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept> matches anything including a newline sequence. By default, DotAll is off hence <bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept> does not match a newline sequence.</source>
<seg-source><mrk mid="0" mtype="seg">Single-line or <bpt id="1" ctype="x-em">&lt;em></bpt>DotAll<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk> <mrk mid="2" mtype="seg">matches anything including a newline sequence.</mrk> <mrk mid="3" mtype="seg">By default, DotAll is off hence <bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk> <mrk mid="4" mtype="seg">does not match a newline sequence.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Single-line or <bpt id="1" ctype="x-em">&lt;em></bpt>DotAll<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk> <mrk mid="2" mtype="seg">matches anything including a newline sequence.</mrk> <mrk mid="3" mtype="seg">By default, DotAll is off hence <bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk> <mrk mid="4" mtype="seg">does not match a newline sequence.</mrk></target>
</trans-unit>
<trans-unit id="85">
<source xml:lang="en"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?U)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">U)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">U)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></target>
</trans-unit>
<trans-unit id="86">
<source xml:lang="en">Ungreedy: quantifiers become lazy (non-greedy) from that point on. By default, matching is greedy - see below for further explanation.</source>
<seg-source><mrk mid="0" mtype="seg">Ungreedy: quantifiers become lazy (non-greedy) from that point on.</mrk> <mrk mid="1" mtype="seg">By default, matching is greedy - see below for further explanation.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Ungreedy: quantifiers become lazy (non-greedy) from that point on.</mrk> <mrk mid="1" mtype="seg">By default, matching is greedy - see below for further explanation.</mrk></target>
</trans-unit>
<trans-unit id="87">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?x)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?x)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?x)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="88">
<source xml:lang="en">eXtended: whitespaces outside character classes are ignored and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> starts a comment up to the next solid newline in pattern. Meaningless whitespaces between components make regular expressions much more readable. By default, whitespaces match themselves and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> is a literal character.</source>
<seg-source><mrk mid="0" mtype="seg">eXtended: whitespaces outside character classes are ignored and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> starts a comment up to the next solid newline in pattern.</mrk> <mrk mid="1" mtype="seg">Meaningless whitespaces between components make regular expressions much more readable.</mrk> <mrk mid="2" mtype="seg">By default, whitespaces match themselves and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> is a literal character.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">eXtended: whitespaces outside character classes are ignored and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> starts a comment up to the next solid newline in pattern.</mrk> <mrk mid="1" mtype="seg">Meaningless whitespaces between components make regular expressions much more readable.</mrk> <mrk mid="2" mtype="seg">By default, whitespaces match themselves and <bpt id="1" ctype="x-strong">&lt;strong></bpt>#<ept id="1">&lt;/strong></ept> is a literal character.</mrk></target>
</trans-unit>
<trans-unit id="89">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Characters<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Characters<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Characters<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="90">
<source xml:lang="en"> Regular expressions patterns consist of literal Unicode text parts which match themselves, intermixed with regular expression specifiers or options. Specifiers and options use a few <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> which have a special meaning by themselves or introduce special pattern elements described in the tables below.</source>
<seg-source> <mrk mid="0" mtype="seg">Regular expressions patterns consist of literal Unicode text parts which match themselves, intermixed with regular expression specifiers or options.</mrk> <mrk mid="1" mtype="seg">Specifiers and options use a few <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> which have a special meaning by themselves or introduce special pattern elements described in the tables below.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Regular expressions patterns consist of literal Unicode text parts which match themselves, intermixed with regular expression specifiers or options.</mrk> <mrk mid="1" mtype="seg">Specifiers and options use a few <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> which have a special meaning by themselves or introduce special pattern elements described in the tables below.</mrk></target>
</trans-unit>
<trans-unit id="91">
<source xml:lang="en"> In literal parts, alphanumeric characters always stand for themselves: the pattern "literal part with " matches exactly the string "literal part with " ("" means "chinese text".)</source>
<seg-source> <mrk mid="0" mtype="seg">In literal parts, alphanumeric characters always stand for themselves: the pattern "literal part with " matches exactly the string "literal part with " ("" means "chinese text".)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">In literal parts, alphanumeric characters always stand for themselves: the pattern "literal part with " matches exactly the string "literal part with " ("" means "chinese text".)</mrk></target>
</trans-unit>
<trans-unit id="92">
<source xml:lang="en"> Some non-alphanumeric characters called <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> have special behavior, discussed thereafter.</source>
<seg-source> <mrk mid="0" mtype="seg">Some non-alphanumeric characters called <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> have special behavior, discussed thereafter.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Some non-alphanumeric characters called <bpt id="1" ctype="x-u">&lt;u></bpt>metacharacters<ept id="1">&lt;/u></ept> have special behavior, discussed thereafter.</mrk></target>
</trans-unit>
<trans-unit id="93">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Representing some characters literally<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Representing some characters literally<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Representing some characters literally<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="94">
<source xml:lang="en"> The special sequences below are used to represent certain characters literally.</source>
<seg-source> <mrk mid="0" mtype="seg">The special sequences below are used to represent certain characters literally.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">The special sequences below are used to represent certain characters literally.</mrk></target>
</trans-unit>
<trans-unit id="95">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\a<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\a<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\a<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="96">
<source xml:lang="en">Represents "alarm", the BEL character (Chr(7)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "alarm", the BEL character (Chr(7)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "alarm", the BEL character (Chr(7)).</mrk></target>
</trans-unit>
<trans-unit id="97">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\c<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\c<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\c<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="98">
<source xml:lang="en">Represents "control-<bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept>", where <bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept> is any 7-bit ASCII character. For example, "\cM" represents ctrl-M, same as \x0D or \r (Chr(13)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "control-<bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept>", where <bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept> is any 7-bit ASCII character.</mrk> <mrk mid="1" mtype="seg">For example, "\cM" represents ctrl-M, same as \x0D or \r (Chr(13)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "control-<bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept>", where <bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept> is any 7-bit ASCII character.</mrk> <mrk mid="1" mtype="seg">For example, "\cM" represents ctrl-M, same as \x0D or \r (Chr(13)).</mrk></target>
</trans-unit>
<trans-unit id="99">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\e<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\e<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\e<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="100">
<source xml:lang="en">Represents the "escape" control character (Chr(27)). <bpt id="1" ctype="x-em">&lt;em></bpt>Not to be confused with the escaping of a character!<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg">Represents the "escape" control character (Chr(27)).</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Not to be confused with the escaping of a character!<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents the "escape" control character (Chr(27)).</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>Not to be confused with the escaping of a character!<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="101">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\f<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\f<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\f<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="102">
<source xml:lang="en">Represents "formfeed" (Chr(12)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "formfeed" (Chr(12)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "formfeed" (Chr(12)).</mrk></target>
</trans-unit>
<trans-unit id="103">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\n<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\n<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\n<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="104">
<source xml:lang="en">Represents "linefeed" (@LF, Chr(10)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "linefeed" (@LF, Chr(10)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "linefeed" (@LF, Chr(10)).</mrk></target>
</trans-unit>
<trans-unit id="105">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\r<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\r<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\r<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="106">
<source xml:lang="en">Represents "carriage return" (@CR, Chr(13)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "carriage return" (@CR, Chr(13)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "carriage return" (@CR, Chr(13)).</mrk></target>
</trans-unit>
<trans-unit id="107">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\t<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\t<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\t<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="108">
<source xml:lang="en">Represents "tab" (@TAB, Chr(9)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents "tab" (@TAB, Chr(9)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents "tab" (@TAB, Chr(9)).</mrk></target>
</trans-unit>
<trans-unit id="109">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="110">
<source xml:lang="en">Represents character with octal code <bpt id="1" ctype="x-em">&lt;em></bpt>ddd<ept id="1">&lt;/em></ept>, OR backreference to capturing group number <bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept> in decimal. For example, <bpt id="1" ctype="x-strong">&lt;strong></bpt>([a-z])\1<ept id="1">&lt;/strong></ept> would match a doubled letter.</source>
<seg-source><mrk mid="0" mtype="seg">Represents character with octal code <bpt id="1" ctype="x-em">&lt;em></bpt>ddd<ept id="1">&lt;/em></ept>, OR backreference to capturing group number <bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept> in decimal.</mrk> <mrk mid="1" mtype="seg">For example, <bpt id="1" ctype="x-strong">&lt;strong></bpt>([a-z])\1<ept id="1">&lt;/strong></ept> would match a doubled letter.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents character with octal code <bpt id="1" ctype="x-em">&lt;em></bpt>ddd<ept id="1">&lt;/em></ept>, OR backreference to capturing group number <bpt id="2" ctype="x-em">&lt;em></bpt>ddd<ept id="2">&lt;/em></ept> in decimal.</mrk> <mrk mid="1" mtype="seg">For example, <bpt id="1" ctype="x-strong">&lt;strong></bpt>([a-z])\1<ept id="1">&lt;/strong></ept> would match a doubled letter.</mrk></target>
</trans-unit>
<trans-unit id="111">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Best avoided<ept id="1">&lt;/strong></ept> as it can be ambiguous! Favor the hex representations below.</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Best avoided<ept id="1">&lt;/strong></ept> as it can be ambiguous!</mrk> <mrk mid="1" mtype="seg">Favor the hex representations below.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Best avoided<ept id="1">&lt;/strong></ept> as it can be ambiguous!</mrk> <mrk mid="1" mtype="seg">Favor the hex representations below.</mrk></target>
</trans-unit>
<trans-unit id="112">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hh<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hh<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hh<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="113">
<source xml:lang="en">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hh<ept id="1">&lt;/em></ept>: "\x7E" represents a tilde, "~".</source>
<seg-source><mrk mid="0" mtype="seg">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hh<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"\x7E" represents a tilde, "~".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hh<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"\x7E" represents a tilde, "~".</mrk></target>
</trans-unit>
<trans-unit id="114">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hhhh<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hhhh<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\x{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>hhhh<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="115">
<source xml:lang="en">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hhhh<ept id="1">&lt;/em></ept>: "\x{20AC}" represents the Euro symbol, "" (ChrW(0x20AC)).</source>
<seg-source><mrk mid="0" mtype="seg">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hhhh<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"\x{20AC}" represents the Euro symbol, "" (ChrW(0x20AC)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Represents Unicode character with hex codepoint <bpt id="1" ctype="x-em">&lt;em></bpt>hhhh<ept id="1">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"\x{20AC}" represents the Euro symbol, "" (ChrW(0x20AC)).</mrk></target>
</trans-unit>
<trans-unit id="116">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="117">
<source xml:lang="en">where <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> is non-alphanumeric, stands for a literal <bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept>. Used to represent metacharacters literally: "\.\[" represents a dot followed by a left square bracket, ".[".</source>
<seg-source><mrk mid="0" mtype="seg">where <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> is non-alphanumeric, stands for a literal <bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept>.</mrk> <mrk mid="1" mtype="seg">Used to represent metacharacters literally:</mrk> <mrk mid="2" mtype="seg">"\.\[" represents a dot followed by a left square bracket, ".[".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">where <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> is non-alphanumeric, stands for a literal <bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept>.</mrk> <mrk mid="1" mtype="seg">Used to represent metacharacters literally:</mrk> <mrk mid="2" mtype="seg">"\.\[" represents a dot followed by a left square bracket, ".[".</mrk></target>
</trans-unit>
<trans-unit id="118">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> ... <bpt id="1" ctype="x-strong">&lt;strong></bpt>\E<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> ...</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\E<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> ...</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\E<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="119">
<source xml:lang="en">Verbatim sequence: metacharacters loose their special meaning between <bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>\E<ept id="2">&lt;/strong></ept>: "\Q(.)\E" matches "(.)" and is equivalent to, but more readable than, "\(\.\)".</source>
<seg-source><mrk mid="0" mtype="seg">Verbatim sequence: metacharacters loose their special meaning between <bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>\E<ept id="2">&lt;/strong></ept>:</mrk> <mrk mid="1" mtype="seg">"\Q(.)\E" matches "(.)" and is equivalent to, but more readable than, "\(\.\)".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Verbatim sequence: metacharacters loose their special meaning between <bpt id="1" ctype="x-strong">&lt;strong></bpt>\Q<ept id="1">&lt;/strong></ept> and <bpt id="2" ctype="x-strong">&lt;strong></bpt>\E<ept id="2">&lt;/strong></ept>:</mrk> <mrk mid="1" mtype="seg">"\Q(.)\E" matches "(.)" and is equivalent to, but more readable than, "\(\.\)".</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="120">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Metacharacters<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Metacharacters<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Metacharacters<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="121">
<source xml:lang="en"> PCRE metacharacters are <it id="1" ctype="x-strong" pos="open">&lt;strong></it>\ . ^ $ | [ ( { * + ? #<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> which have one or more special meaning, depending on context.</source>
<seg-source> <mrk mid="0" mtype="seg">PCRE metacharacters are <it id="1" ctype="x-strong" pos="open">&lt;strong></it>\ .</mrk> <mrk mid="1" mtype="seg">^ $ | [ ( { * + ?</mrk> <mrk mid="2" mtype="seg">#<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> which have one or more special meaning, depending on context.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">PCRE metacharacters are <it id="1" ctype="x-strong" pos="open">&lt;strong></it>\ .</mrk> <mrk mid="1" mtype="seg">^ $ | [ ( { * + ?</mrk> <mrk mid="2" mtype="seg">#<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> which have one or more special meaning, depending on context.</mrk></target>
</trans-unit>
<trans-unit id="122">
<source xml:lang="en"> To insert a literal metacharacter, precede it by adding a backslash (this is called <bpt id="1" ctype="x-strong">&lt;strong></bpt>escaping (or quoting) a character<ept id="1">&lt;/strong></ept>): "\$" means the dollar character.</source>
<seg-source> <mrk mid="0" mtype="seg">To insert a literal metacharacter, precede it by adding a backslash (this is called <bpt id="1" ctype="x-strong">&lt;strong></bpt>escaping (or quoting) a character<ept id="1">&lt;/strong></ept>):</mrk> <mrk mid="1" mtype="seg">"\$" means the dollar character.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">To insert a literal metacharacter, precede it by adding a backslash (this is called <bpt id="1" ctype="x-strong">&lt;strong></bpt>escaping (or quoting) a character<ept id="1">&lt;/strong></ept>):</mrk> <mrk mid="1" mtype="seg">"\$" means the dollar character.</mrk></target>
</trans-unit>
<trans-unit id="123">
<source xml:lang="en"> Metacharacters will be discussed in separate sections where their behavior or meaning belong.</source>
<seg-source> <mrk mid="0" mtype="seg">Metacharacters will be discussed in separate sections where their behavior or meaning belong.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Metacharacters will be discussed in separate sections where their behavior or meaning belong.</mrk></target>
</trans-unit>
<trans-unit id="124">
<source xml:lang="en"><bpt id="1" ctype="x-u">&lt;u></bpt>Character types<ept id="1">&lt;/u></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Character types<ept id="1">&lt;/u></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Character types<ept id="1">&lt;/u></ept></mrk></target>
</trans-unit>
<trans-unit id="125">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>.<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="126">
<source xml:lang="en">Matches any single character except, by default, a newline sequence. Matches newlines as well when option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept> is active.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any single character except, by default, a newline sequence.</mrk> <mrk mid="1" mtype="seg">Matches newlines as well when option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept> is active.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any single character except, by default, a newline sequence.</mrk> <mrk mid="1" mtype="seg">Matches newlines as well when option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept> is active.</mrk></target>
</trans-unit>
<trans-unit id="127">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="128">
<source xml:lang="en">Matches any decimal digit (any Unicode decimal digit in any language when UCP is enabled).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any decimal digit (any Unicode decimal digit in any language when UCP is enabled).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any decimal digit (any Unicode decimal digit in any language when UCP is enabled).</mrk></target>
</trans-unit>
<trans-unit id="129">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\D<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\D<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\D<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="130">
<source xml:lang="en">Matches any non-digit.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any non-digit.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any non-digit.</mrk></target>
</trans-unit>
<trans-unit id="131">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="132">
<source xml:lang="en">Matches any horizontal whitespace character (see table below).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any horizontal whitespace character (see table below).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any horizontal whitespace character (see table below).</mrk></target>
</trans-unit>
<trans-unit id="133">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\H<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\H<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\H<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="134">
<source xml:lang="en">Matches any character that is not a horizontal whitespace character.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any character that is not a horizontal whitespace character.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any character that is not a horizontal whitespace character.</mrk></target>
</trans-unit>
<trans-unit id="135">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\N<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\N<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\N<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="136">
<source xml:lang="en">Matches any character except a newline sequence regardless of option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any character except a newline sequence regardless of option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any character except a newline sequence regardless of option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?s)<ept id="1">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="137">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\p{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\p{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\p{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="138">
<source xml:lang="en">Only when UCP is enabled: matches any Unicode character having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>. E.g. "\b\p{Cyrillic}+" matches any cyrillic word; "\p{Sc}" matches any currency symbol. See reference documentation for details.</source>
<seg-source><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode character having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>.</mrk> <mrk mid="1" mtype="seg">E.g.</mrk> <mrk mid="2" mtype="seg">"\b\p{Cyrillic}+" matches any cyrillic word; "\p{Sc}" matches any currency symbol.</mrk> <mrk mid="3" mtype="seg">See reference documentation for details.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode character having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>.</mrk> <mrk mid="1" mtype="seg">E.g.</mrk> <mrk mid="2" mtype="seg">"\b\p{Cyrillic}+" matches any cyrillic word; "\p{Sc}" matches any currency symbol.</mrk> <mrk mid="3" mtype="seg">See reference documentation for details.</mrk></target>
</trans-unit>
<trans-unit id="139">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\P{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\P{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\P{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>ppp<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="140">
<source xml:lang="en">Only when UCP is enabled: matches any Unicode character not having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode character not having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode character not having the property <bpt id="1" ctype="x-em">&lt;em></bpt>ppp<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="141">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="142">
<source xml:lang="en">Matches any Unicode newline sequence by default, or the currently active (*BSR_...) setting. By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches "(?>\r\n|\n|\r)" where "(?>...)" is an atomic group, making the sequence "\r\n" (@CRLF) unbreakable.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any Unicode newline sequence by default, or the currently active (*BSR_...) setting.</mrk> <mrk mid="1" mtype="seg">By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches "(?>\r\n|\n|\r)" where "(?>...)" is an atomic group, making the sequence "\r\n" (@CRLF) unbreakable.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any Unicode newline sequence by default, or the currently active (*BSR_...) setting.</mrk> <mrk mid="1" mtype="seg">By default <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept> matches "(?>\r\n|\n|\r)" where "(?>...)" is an atomic group, making the sequence "\r\n" (@CRLF) unbreakable.</mrk></target>
</trans-unit>
<trans-unit id="143">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="144">
<source xml:lang="en">Matches any whitespace character (see table below).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any whitespace character (see table below).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any whitespace character (see table below).</mrk></target>
</trans-unit>
<trans-unit id="145">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\S<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\S<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\S<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="146">
<source xml:lang="en">Matches any non-whitespace character.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any non-whitespace character.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any non-whitespace character.</mrk></target>
</trans-unit>
<trans-unit id="147">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="148">
<source xml:lang="en">Matches any vertical whitespace character (see table below).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any vertical whitespace character (see table below).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any vertical whitespace character (see table below).</mrk></target>
</trans-unit>
<trans-unit id="149">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\V<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\V<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\V<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="150">
<source xml:lang="en">Matches any character that is not a vertical whitespace character.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any character that is not a vertical whitespace character.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any character that is not a vertical whitespace character.</mrk></target>
</trans-unit>
<trans-unit id="151">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="152">
<source xml:lang="en">Matches any "word" character: any digit, any letter or underscore "_" (any Unicode digit, any Unicode letter in any language or underscore "_" when UCP is enabled).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any "word" character: any digit, any letter or underscore "_" (any Unicode digit, any Unicode letter in any language or underscore "_" when UCP is enabled).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any "word" character: any digit, any letter or underscore "_" (any Unicode digit, any Unicode letter in any language or underscore "_" when UCP is enabled).</mrk></target>
</trans-unit>
<trans-unit id="153">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\W<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\W<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\W<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="154">
<source xml:lang="en">Matches any non-word character.</source>
<seg-source><mrk mid="0" mtype="seg">Matches any non-word character.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any non-word character.</mrk></target>
</trans-unit>
<trans-unit id="155">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="156">
<source xml:lang="en">Only when UCP is enabled: matches any Unicode extended grapheme cluster - an unbreakable sequence of codepoints which represent a single character for the user. As a consequence <bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept> may match more than one character in the subject string, contrary to all other sequences in this table.</source>
<seg-source><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode extended grapheme cluster - an unbreakable sequence of codepoints which represent a single character for the user.</mrk> <mrk mid="1" mtype="seg">As a consequence <bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept> may match more than one character in the subject string, contrary to all other sequences in this table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Only when UCP is enabled: matches any Unicode extended grapheme cluster - an unbreakable sequence of codepoints which represent a single character for the user.</mrk> <mrk mid="1" mtype="seg">As a consequence <bpt id="1" ctype="x-strong">&lt;strong></bpt>\X<ept id="1">&lt;/strong></ept> may match more than one character in the subject string, contrary to all other sequences in this table.</mrk></target>
</trans-unit>
<trans-unit id="157">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Horizontal whitespace characters matched by \h<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Horizontal whitespace characters matched by \h<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Horizontal whitespace characters matched by \h<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="158">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> is equivalent to "[\x09 \xA0]" by default (or "[\x09 \xA0\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]" when UCP is enabled.)</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> is equivalent to "[\x09 \xA0]" by default (or "[\x09 \xA0\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]" when UCP is enabled.)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> is equivalent to "[\x09 \xA0]" by default (or "[\x09 \xA0\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]" when UCP is enabled.)</mrk></target>
</trans-unit>
<trans-unit id="159">
<source xml:lang="en"> This set is: Horizontal tab (HT), Space, Non-break space (adding: Ogham space mark, Mongolian vowel separator, En quad, Em quad, En space, Em space, Three-per-em space, Four-per-em space, Six-per-em space, Figure space, Punctuation space, Thin space, Hair space, Narrow no-break space, Medium mathematical space, Ideographic space when UCP is enabled.)</source>
<seg-source> <mrk mid="0" mtype="seg">This set is:</mrk> <mrk mid="1" mtype="seg">Horizontal tab (HT), Space, Non-break space (adding:</mrk> <mrk mid="2" mtype="seg">Ogham space mark, Mongolian vowel separator, En quad, Em quad, En space, Em space, Three-per-em space, Four-per-em space, Six-per-em space, Figure space, Punctuation space, Thin space, Hair space, Narrow no-break space, Medium mathematical space, Ideographic space when UCP is enabled.)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">This set is:</mrk> <mrk mid="1" mtype="seg">Horizontal tab (HT), Space, Non-break space (adding:</mrk> <mrk mid="2" mtype="seg">Ogham space mark, Mongolian vowel separator, En quad, Em quad, En space, Em space, Three-per-em space, Four-per-em space, Six-per-em space, Figure space, Punctuation space, Thin space, Hair space, Narrow no-break space, Medium mathematical space, Ideographic space when UCP is enabled.)</mrk></target>
</trans-unit>
<trans-unit id="160">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Vertical whitespace characters matched by \v<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Vertical whitespace characters matched by \v<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Vertical whitespace characters matched by \v<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="161">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept> is equivalent to "[\x0A-\x0D]" by default (or "[\x0A-\x0D\x{0085}\x{2028}\x{2029}]" when UCP is enabled.)</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept> is equivalent to "[\x0A-\x0D]" by default (or "[\x0A-\x0D\x{0085}\x{2028}\x{2029}]" when UCP is enabled.)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\v<ept id="1">&lt;/strong></ept> is equivalent to "[\x0A-\x0D]" by default (or "[\x0A-\x0D\x{0085}\x{2028}\x{2029}]" when UCP is enabled.)</mrk></target>
</trans-unit>
<trans-unit id="162">
<source xml:lang="en"> This set is: Linefeed (LF), Vertical tab (VT), Form feed (FF), Carriage return (CR) (adding: Next line (NEL), Line separator, Paragraph separator when UCP is enabled.)</source>
<seg-source> <mrk mid="0" mtype="seg">This set is:</mrk> <mrk mid="1" mtype="seg">Linefeed (LF), Vertical tab (VT), Form feed (FF), Carriage return (CR) (adding:</mrk> <mrk mid="2" mtype="seg">Next line (NEL), Line separator, Paragraph separator when UCP is enabled.)</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">This set is:</mrk> <mrk mid="1" mtype="seg">Linefeed (LF), Vertical tab (VT), Form feed (FF), Carriage return (CR) (adding:</mrk> <mrk mid="2" mtype="seg">Next line (NEL), Line separator, Paragraph separator when UCP is enabled.)</mrk></target>
</trans-unit>
<trans-unit id="163">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by \s<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by \s<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by \s<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="164">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> is equivalent to "[\h\x0A\x0C\x0D]".</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> is equivalent to "[\h\x0A\x0C\x0D]".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> is equivalent to "[\h\x0A\x0C\x0D]".</mrk></target>
</trans-unit>
<trans-unit id="165">
<source xml:lang="en"> This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> plus Linefeed (LF), Form feed (FF), Carriage return (CR).</source>
<seg-source> <mrk mid="0" mtype="seg">This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> plus Linefeed (LF), Form feed (FF), Carriage return (CR).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\h<ept id="1">&lt;/strong></ept> plus Linefeed (LF), Form feed (FF), Carriage return (CR).</mrk></target>
</trans-unit>
<trans-unit id="166">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by [[:space:]]<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by [[:space:]]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Whitespace characters matched by [[:space:]]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="167">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>[[:space:]]<ept id="1">&lt;/strong></ept> is equivalent to "\s".</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[[:space:]]<ept id="1">&lt;/strong></ept> is equivalent to "\s".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[[:space:]]<ept id="1">&lt;/strong></ept> is equivalent to "\s".</mrk></target>
</trans-unit>
<trans-unit id="168">
<source xml:lang="en"> This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> plus Vertical tab (VT).</source>
<seg-source> <mrk mid="0" mtype="seg">This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> plus Vertical tab (VT).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">This set is: all characters in <bpt id="1" ctype="x-strong">&lt;strong></bpt>\s<ept id="1">&lt;/strong></ept> plus Vertical tab (VT).</mrk></target>
</trans-unit>
<trans-unit id="169">
<source xml:lang="en"><bpt id="1" ctype="x-u">&lt;u></bpt>Character classes and POSIX classes<ept id="1">&lt;/u></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Character classes and POSIX classes<ept id="1">&lt;/u></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-u">&lt;u></bpt>Character classes and POSIX classes<ept id="1">&lt;/u></ept></mrk></target>
</trans-unit>
<trans-unit id="170">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Character classes<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Character classes<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Character classes<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="171">
<source xml:lang="en"> A character classes defines a set of allowed (resp. disallowed) characters, which the next character in subject is expected to match (resp. not to match).</source>
<seg-source> <mrk mid="0" mtype="seg">A character classes defines a set of allowed (resp. disallowed) characters, which the next character in subject is expected to match (resp. not to match).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">A character classes defines a set of allowed (resp. disallowed) characters, which the next character in subject is expected to match (resp. not to match).</mrk></target>
</trans-unit>
<trans-unit id="172">
<source xml:lang="en"> Inside a character classes, most metacharacters loose their meaning (like $ . or *) or mean something else (like ^).</source>
<seg-source> <mrk mid="0" mtype="seg">Inside a character classes, most metacharacters loose their meaning (like $ .</mrk> <mrk mid="1" mtype="seg">or *) or mean something else (like ^).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Inside a character classes, most metacharacters loose their meaning (like $ .</mrk> <mrk mid="1" mtype="seg">or *) or mean something else (like ^).</mrk></target>
</trans-unit>
<trans-unit id="173">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="174">
<source xml:lang="en">Matches any character in the explicit set: "[aeiou]" matches any lowercase vowel. A contiguous (in Unicode codepoint increasing order) set can be defined by putting an hyphen between the starting and ending characters: "[a-z]" matches any lowercase ASCII letter. To include a hyphen (-) in a set, put it as the first or last character of the set or escape it (\-).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any character in the explicit set:</mrk> <mrk mid="1" mtype="seg">"[aeiou]" matches any lowercase vowel.</mrk> <mrk mid="2" mtype="seg">A contiguous (in Unicode codepoint increasing order) set can be defined by putting an hyphen between the starting and ending characters:</mrk> <mrk mid="3" mtype="seg">"[a-z]" matches any lowercase ASCII letter.</mrk> <mrk mid="4" mtype="seg">To include a hyphen (-) in a set, put it as the first or last character of the set or escape it (\-).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any character in the explicit set:</mrk> <mrk mid="1" mtype="seg">"[aeiou]" matches any lowercase vowel.</mrk> <mrk mid="2" mtype="seg">A contiguous (in Unicode codepoint increasing order) set can be defined by putting an hyphen between the starting and ending characters:</mrk> <mrk mid="3" mtype="seg">"[a-z]" matches any lowercase ASCII letter.</mrk> <mrk mid="4" mtype="seg">To include a hyphen (-) in a set, put it as the first or last character of the set or escape it (\-).</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="175">
<source xml:lang="en"> Notice that the pattern "[A-z]" is not the same as "[A-Za-z]": the former is equivalent to "[A-Z\[\\\]^_`a-z]".</source>
<seg-source> <mrk mid="0" mtype="seg">Notice that the pattern "[A-z]" is not the same as "[A-Za-z]": the former is equivalent to "[A-Z\[\\\]^_`a-z]".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Notice that the pattern "[A-z]" is not the same as "[A-Za-z]": the former is equivalent to "[A-Z\[\\\]^_`a-z]".</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="176">
<source xml:lang="en"> To include a closing bracket in a set, use it as the first character of the set or escape it: "[][]" and "[\[\]]" will both match either "[" or "]".</source>
<seg-source> <mrk mid="0" mtype="seg">To include a closing bracket in a set, use it as the first character of the set or escape it:</mrk> <mrk mid="1" mtype="seg">"[][]" and "[\[\]]" will both match either "[" or "]".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">To include a closing bracket in a set, use it as the first character of the set or escape it:</mrk> <mrk mid="1" mtype="seg">"[][]" and "[\[\]]" will both match either "[" or "]".</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="177">
<source xml:lang="en"> Note that in a character class, only <bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept>, <bpt id="2" ctype="x-strong">&lt;strong></bpt>\D<ept id="2">&lt;/strong></ept>, <bpt id="3" ctype="x-strong">&lt;strong></bpt>\h<ept id="3">&lt;/strong></ept>, <bpt id="4" ctype="x-strong">&lt;strong></bpt>\H<ept id="4">&lt;/strong></ept>, <bpt id="5" ctype="x-strong">&lt;strong></bpt>\p{}<ept id="5">&lt;/strong></ept>, <bpt id="6" ctype="x-strong">&lt;strong></bpt>\P{}<ept id="6">&lt;/strong></ept>, <bpt id="7" ctype="x-strong">&lt;strong></bpt>\s<ept id="7">&lt;/strong></ept>, <bpt id="8" ctype="x-strong">&lt;strong></bpt>\Q<ept id="8">&lt;/strong></ept>...<bpt id="9" ctype="x-strong">&lt;strong></bpt>\E<ept id="9">&lt;/strong></ept>, <bpt id="10" ctype="x-strong">&lt;strong></bpt>\S<ept id="10">&lt;/strong></ept>, <bpt id="11" ctype="x-strong">&lt;strong></bpt>\v<ept id="11">&lt;/strong></ept>, <bpt id="12" ctype="x-strong">&lt;strong></bpt>\V<ept id="12">&lt;/strong></ept>, <bpt id="13" ctype="x-strong">&lt;strong></bpt>\w<ept id="13">&lt;/strong></ept>, <bpt id="14" ctype="x-strong">&lt;strong></bpt>\W<ept id="14">&lt;/strong></ept>, and <bpt id="15" ctype="x-strong">&lt;strong></bpt>\x<ept id="15">&lt;/strong></ept> sequences retain their special meaning, while <bpt id="16" ctype="x-strong">&lt;strong></bpt>\b<ept id="16">&lt;/strong></ept> means the backspace character (Chr(8)).</source>
<seg-source> <mrk mid="0" mtype="seg">Note that in a character class, only <bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept>, <bpt id="2" ctype="x-strong">&lt;strong></bpt>\D<ept id="2">&lt;/strong></ept>, <bpt id="3" ctype="x-strong">&lt;strong></bpt>\h<ept id="3">&lt;/strong></ept>, <bpt id="4" ctype="x-strong">&lt;strong></bpt>\H<ept id="4">&lt;/strong></ept>, <bpt id="5" ctype="x-strong">&lt;strong></bpt>\p{}<ept id="5">&lt;/strong></ept>, <bpt id="6" ctype="x-strong">&lt;strong></bpt>\P{}<ept id="6">&lt;/strong></ept>, <bpt id="7" ctype="x-strong">&lt;strong></bpt>\s<ept id="7">&lt;/strong></ept>, <bpt id="8" ctype="x-strong">&lt;strong></bpt>\Q<ept id="8">&lt;/strong></ept>...<bpt id="9" ctype="x-strong">&lt;strong></bpt>\E<ept id="9">&lt;/strong></ept>, <bpt id="10" ctype="x-strong">&lt;strong></bpt>\S<ept id="10">&lt;/strong></ept>, <bpt id="11" ctype="x-strong">&lt;strong></bpt>\v<ept id="11">&lt;/strong></ept>, <bpt id="12" ctype="x-strong">&lt;strong></bpt>\V<ept id="12">&lt;/strong></ept>, <bpt id="13" ctype="x-strong">&lt;strong></bpt>\w<ept id="13">&lt;/strong></ept>, <bpt id="14" ctype="x-strong">&lt;strong></bpt>\W<ept id="14">&lt;/strong></ept>, and <bpt id="15" ctype="x-strong">&lt;strong></bpt>\x<ept id="15">&lt;/strong></ept> sequences retain their special meaning, while <bpt id="16" ctype="x-strong">&lt;strong></bpt>\b<ept id="16">&lt;/strong></ept> means the backspace character (Chr(8)).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Note that in a character class, only <bpt id="1" ctype="x-strong">&lt;strong></bpt>\d<ept id="1">&lt;/strong></ept>, <bpt id="2" ctype="x-strong">&lt;strong></bpt>\D<ept id="2">&lt;/strong></ept>, <bpt id="3" ctype="x-strong">&lt;strong></bpt>\h<ept id="3">&lt;/strong></ept>, <bpt id="4" ctype="x-strong">&lt;strong></bpt>\H<ept id="4">&lt;/strong></ept>, <bpt id="5" ctype="x-strong">&lt;strong></bpt>\p{}<ept id="5">&lt;/strong></ept>, <bpt id="6" ctype="x-strong">&lt;strong></bpt>\P{}<ept id="6">&lt;/strong></ept>, <bpt id="7" ctype="x-strong">&lt;strong></bpt>\s<ept id="7">&lt;/strong></ept>, <bpt id="8" ctype="x-strong">&lt;strong></bpt>\Q<ept id="8">&lt;/strong></ept>...<bpt id="9" ctype="x-strong">&lt;strong></bpt>\E<ept id="9">&lt;/strong></ept>, <bpt id="10" ctype="x-strong">&lt;strong></bpt>\S<ept id="10">&lt;/strong></ept>, <bpt id="11" ctype="x-strong">&lt;strong></bpt>\v<ept id="11">&lt;/strong></ept>, <bpt id="12" ctype="x-strong">&lt;strong></bpt>\V<ept id="12">&lt;/strong></ept>, <bpt id="13" ctype="x-strong">&lt;strong></bpt>\w<ept id="13">&lt;/strong></ept>, <bpt id="14" ctype="x-strong">&lt;strong></bpt>\W<ept id="14">&lt;/strong></ept>, and <bpt id="15" ctype="x-strong">&lt;strong></bpt>\x<ept id="15">&lt;/strong></ept> sequences retain their special meaning, while <bpt id="16" ctype="x-strong">&lt;strong></bpt>\b<ept id="16">&lt;/strong></ept> means the backspace character (Chr(8)).</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="178">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[^<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[^<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[^<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>]<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="179">
<source xml:lang="en">Matches any character <bpt id="1" ctype="x-strong">&lt;strong></bpt>not<ept id="1">&lt;/strong></ept> in the set: "[^0-9]" matches any non-digit. To include a caret (^) in a set, put it after the beginning of the set or escape it (\^).</source>
<seg-source><mrk mid="0" mtype="seg">Matches any character <bpt id="1" ctype="x-strong">&lt;strong></bpt>not<ept id="1">&lt;/strong></ept> in the set:</mrk> <mrk mid="1" mtype="seg">"[^0-9]" matches any non-digit.</mrk> <mrk mid="2" mtype="seg">To include a caret (^) in a set, put it after the beginning of the set or escape it (\^).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches any character <bpt id="1" ctype="x-strong">&lt;strong></bpt>not<ept id="1">&lt;/strong></ept> in the set:</mrk> <mrk mid="1" mtype="seg">"[^0-9]" matches any non-digit.</mrk> <mrk mid="2" mtype="seg">To include a caret (^) in a set, put it after the beginning of the set or escape it (\^).</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="180">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>POSIX classes<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>POSIX classes<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>POSIX classes<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="181">
<source xml:lang="en"> These are named sets specifications to be used themselves within a character class: "[z[:digit:]w-y]" is the same as "[w-z0-9]". To negate a POSIX character class, put a caret (^) after the first colon: "[[:^digit:]]".</source>
<seg-source> <mrk mid="0" mtype="seg">These are named sets specifications to be used themselves within a character class:</mrk> <mrk mid="1" mtype="seg">"[z[:digit:]w-y]" is the same as "[w-z0-9]".</mrk> <mrk mid="2" mtype="seg">To negate a POSIX character class, put a caret (^) after the first colon:</mrk> <mrk mid="3" mtype="seg">"[[:^digit:]]".</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">These are named sets specifications to be used themselves within a character class:</mrk> <mrk mid="1" mtype="seg">"[z[:digit:]w-y]" is the same as "[w-z0-9]".</mrk> <mrk mid="2" mtype="seg">To negate a POSIX character class, put a caret (^) after the first colon:</mrk> <mrk mid="3" mtype="seg">"[[:^digit:]]".</mrk></target>
</trans-unit>
<trans-unit id="182">
<source xml:lang="en"> When UCP is enabled, several POSIX classes extend to some Unicode character subset, else they are by default restricted to 7-bit ASCII.</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled, several POSIX classes extend to some Unicode character subset, else they are by default restricted to 7-bit ASCII.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled, several POSIX classes extend to some Unicode character subset, else they are by default restricted to 7-bit ASCII.</mrk></target>
</trans-unit>
<trans-unit id="183">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alnum:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alnum:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alnum:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="184">
<source xml:lang="en">ASCII letters and digits (same as [^\W_] or [A-Za-z0-9]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII letters and digits (same as [^\W_] or [A-Za-z0-9]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII letters and digits (same as [^\W_] or [A-Za-z0-9]).</mrk></target>
</trans-unit>
<trans-unit id="185">
<source xml:lang="en"> When UCP is enabled: Unicode letters and digits (same as [^\W_] or \p{Xan}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode letters and digits (same as [^\W_] or \p{Xan}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode letters and digits (same as [^\W_] or \p{Xan}).</mrk></target>
</trans-unit>
<trans-unit id="186">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alpha:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alpha:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:alpha:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="187">
<source xml:lang="en">ASCII letters (same as [^\W\d_] or [A-Za-z]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII letters (same as [^\W\d_] or [A-Za-z]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII letters (same as [^\W\d_] or [A-Za-z]).</mrk></target>
</trans-unit>
<trans-unit id="188">
<source xml:lang="en"> When UCP is enabled: Unicode letters (same as [^\W\d_] or \p{L}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode letters (same as [^\W\d_] or \p{L}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode letters (same as [^\W\d_] or \p{L}).</mrk></target>
</trans-unit>
<trans-unit id="189">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:ascii:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:ascii:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:ascii:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="190">
<source xml:lang="en">ASCII characters (same as [\x00-\x7F]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII characters (same as [\x00-\x7F]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII characters (same as [\x00-\x7F]).</mrk></target>
</trans-unit>
<trans-unit id="191">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:blank:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:blank:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:blank:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="192">
<source xml:lang="en">Space or Tab (@TAB) (same as \h or [\x09\x20]).</source>
<seg-source><mrk mid="0" mtype="seg">Space or Tab (@TAB) (same as \h or [\x09\x20]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Space or Tab (@TAB) (same as \h or [\x09\x20]).</mrk></target>
</trans-unit>
<trans-unit id="193">
<source xml:lang="en"> When UCP is enabled: Unicode horizontal whitespaces (same as \h).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode horizontal whitespaces (same as \h).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode horizontal whitespaces (same as \h).</mrk></target>
</trans-unit>
<trans-unit id="194">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:cntrl:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:cntrl:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:cntrl:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="195">
<source xml:lang="en">ASCII control characters (same as Chr(0) ... Chr(31) and Chr(127)).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII control characters (same as Chr(0) ...</mrk> <mrk mid="1" mtype="seg">Chr(31) and Chr(127)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII control characters (same as Chr(0) ...</mrk> <mrk mid="1" mtype="seg">Chr(31) and Chr(127)).</mrk></target>
</trans-unit>
<trans-unit id="196">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:digit:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:digit:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:digit:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="197">
<source xml:lang="en">ASCII decimal digits (same as \d or [0-9]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII decimal digits (same as \d or [0-9]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII decimal digits (same as \d or [0-9]).</mrk></target>
</trans-unit>
<trans-unit id="198">
<source xml:lang="en"> When UCP is enabled: Unicode decimal digits (same as \d or \p{Nd}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode decimal digits (same as \d or \p{Nd}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode decimal digits (same as \d or \p{Nd}).</mrk></target>
</trans-unit>
<trans-unit id="199">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:graph:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:graph:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:graph:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="200">
<source xml:lang="en">ASCII printing characters, excluding space (same as Chr(33) ... Chr(126)).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII printing characters, excluding space (same as Chr(33) ...</mrk> <mrk mid="1" mtype="seg">Chr(126)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII printing characters, excluding space (same as Chr(33) ...</mrk> <mrk mid="1" mtype="seg">Chr(126)).</mrk></target>
</trans-unit>
<trans-unit id="201">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:lower:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:lower:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:lower:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="202">
<source xml:lang="en">ASCII lowercase letters (same as [a-z]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII lowercase letters (same as [a-z]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII lowercase letters (same as [a-z]).</mrk></target>
</trans-unit>
<trans-unit id="203">
<source xml:lang="en"> When UCP is enabled: Unicode lowercase letters (same as \p{Ll}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode lowercase letters (same as \p{Ll}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode lowercase letters (same as \p{Ll}).</mrk></target>
</trans-unit>
<trans-unit id="204">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:print:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:print:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:print:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="205">
<source xml:lang="en">ASCII printing characters, including space (same as Chr(32) ... Chr(126)).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII printing characters, including space (same as Chr(32) ...</mrk> <mrk mid="1" mtype="seg">Chr(126)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII printing characters, including space (same as Chr(32) ...</mrk> <mrk mid="1" mtype="seg">Chr(126)).</mrk></target>
</trans-unit>
<trans-unit id="206">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:punct:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:punct:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:punct:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="207">
<source xml:lang="en">ASCII punctuation characters, [:print:] excluding [:alnum:] and space, (33-47, 58-64, 91-96, 123-126).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII punctuation characters, [:print:] excluding [:alnum:] and space, (33-47, 58-64, 91-96, 123-126).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII punctuation characters, [:print:] excluding [:alnum:] and space, (33-47, 58-64, 91-96, 123-126).</mrk></target>
</trans-unit>
<trans-unit id="208">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="209">
<source xml:lang="en">ASCII white space (same as [\h\x0A-\x0D]). <bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept> is not quite the same as <bpt id="2" ctype="x-strong">&lt;strong></bpt>\s<ept id="2">&lt;/strong></ept>: it includes VT, Chr(11)).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII white space (same as [\h\x0A-\x0D]).</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept> is not quite the same as <bpt id="2" ctype="x-strong">&lt;strong></bpt>\s<ept id="2">&lt;/strong></ept>: it includes VT, Chr(11)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII white space (same as [\h\x0A-\x0D]).</mrk> <mrk mid="1" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:space:]<ept id="1">&lt;/strong></ept> is not quite the same as <bpt id="2" ctype="x-strong">&lt;strong></bpt>\s<ept id="2">&lt;/strong></ept>: it includes VT, Chr(11)).</mrk></target>
</trans-unit>
<trans-unit id="210">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:upper:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:upper:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:upper:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="211">
<source xml:lang="en">ASCII uppercase letters (same as [A-Z]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII uppercase letters (same as [A-Z]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII uppercase letters (same as [A-Z]).</mrk></target>
</trans-unit>
<trans-unit id="212">
<source xml:lang="en"> When UCP is enabled: Unicode uppercase letters (same as \p{Lu}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode uppercase letters (same as \p{Lu}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode uppercase letters (same as \p{Lu}).</mrk></target>
</trans-unit>
<trans-unit id="213">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:word:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:word:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:word:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="214">
<source xml:lang="en">ASCII "Word" characters (same as \w or [[:alnum:]_]).</source>
<seg-source><mrk mid="0" mtype="seg">ASCII "Word" characters (same as \w or [[:alnum:]_]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ASCII "Word" characters (same as \w or [[:alnum:]_]).</mrk></target>
</trans-unit>
<trans-unit id="215">
<source xml:lang="en"> When UCP is enabled: Unicode "word" characters (same as \w or [[:alnum:]_] or \p{Xwd}).</source>
<seg-source> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode "word" characters (same as \w or [[:alnum:]_] or \p{Xwd}).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">When UCP is enabled:</mrk> <mrk mid="1" mtype="seg">Unicode "word" characters (same as \w or [[:alnum:]_] or \p{Xwd}).</mrk></target>
</trans-unit>
<trans-unit id="216">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:xdigit:]<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:xdigit:]<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>[:xdigit:]<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="217">
<source xml:lang="en">Hexadecimal digits (same as [0-9A-Fa-f]).</source>
<seg-source><mrk mid="0" mtype="seg">Hexadecimal digits (same as [0-9A-Fa-f]).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Hexadecimal digits (same as [0-9A-Fa-f]).</mrk></target>
</trans-unit>
<trans-unit id="218">
<source xml:lang="en"> Groups are used to delimit subpatterns and are the building blocks of powerful expressions. Groups can be either capturing or not and may be nested irrespective of their nature, except comments groups. A regular expression can contain up to 65535 capturing groups.</source>
<seg-source> <mrk mid="0" mtype="seg">Groups are used to delimit subpatterns and are the building blocks of powerful expressions.</mrk> <mrk mid="1" mtype="seg">Groups can be either capturing or not and may be nested irrespective of their nature, except comments groups.</mrk> <mrk mid="2" mtype="seg">A regular expression can contain up to 65535 capturing groups.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Groups are used to delimit subpatterns and are the building blocks of powerful expressions.</mrk> <mrk mid="1" mtype="seg">Groups can be either capturing or not and may be nested irrespective of their nature, except comments groups.</mrk> <mrk mid="2" mtype="seg">A regular expression can contain up to 65535 capturing groups.</mrk></target>
</trans-unit>
<trans-unit id="219">
<source xml:lang="en"> Option letters (discussed above) can be conveniently inserted between the "?" and the ":" of non-capturing groups: "(?-i:[aeiou]{5})" matches 5 lowercase vowels. In this case options are local to the group.</source>
<seg-source> <mrk mid="0" mtype="seg">Option letters (discussed above) can be conveniently inserted between the "?" and the ":" of non-capturing groups:</mrk> <mrk mid="1" mtype="seg">"(?-i:[aeiou]{5})" matches 5 lowercase vowels.</mrk> <mrk mid="2" mtype="seg">In this case options are local to the group.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Option letters (discussed above) can be conveniently inserted between the "?" and the ":" of non-capturing groups:</mrk> <mrk mid="1" mtype="seg">"(?-i:[aeiou]{5})" matches 5 lowercase vowels.</mrk> <mrk mid="2" mtype="seg">In this case options are local to the group.</mrk></target>
</trans-unit>
<trans-unit id="220">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="221">
<source xml:lang="en">Capturing group. The elements in the group are treated in order and can be repeated as a block. E.g. "(ab)+c" will match "abc" or "ababc", but not "abac".</source>
<seg-source><mrk mid="0" mtype="seg">Capturing group.</mrk> <mrk mid="1" mtype="seg">The elements in the group are treated in order and can be repeated as a block.</mrk> <mrk mid="2" mtype="seg">E.g.</mrk> <mrk mid="3" mtype="seg">"(ab)+c" will match "abc" or "ababc", but not "abac".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Capturing group.</mrk> <mrk mid="1" mtype="seg">The elements in the group are treated in order and can be repeated as a block.</mrk> <mrk mid="2" mtype="seg">E.g.</mrk> <mrk mid="3" mtype="seg">"(ab)+c" will match "abc" or "ababc", but not "abac".</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="222">
<source xml:lang="en"> Capturing groups remember the text they matched for use in backreferences and they populate the optionally returned array. They are numbered starting from 1 in the order of appearance of their opening parenthesis.</source>
<seg-source> <mrk mid="0" mtype="seg">Capturing groups remember the text they matched for use in backreferences and they populate the optionally returned array.</mrk> <mrk mid="1" mtype="seg">They are numbered starting from 1 in the order of appearance of their opening parenthesis.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Capturing groups remember the text they matched for use in backreferences and they populate the optionally returned array.</mrk> <mrk mid="1" mtype="seg">They are numbered starting from 1 in the order of appearance of their opening parenthesis.</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="223">
<source xml:lang="en"> Capturing groups may also be treated as subroutines elsewhere in the pattern, possibly recursively.</source>
<seg-source> <mrk mid="0" mtype="seg">Capturing groups may also be treated as subroutines elsewhere in the pattern, possibly recursively.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Capturing groups may also be treated as subroutines elsewhere in the pattern, possibly recursively.</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="224">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept> ... <bpt id="4" ctype="x-strong">&lt;strong></bpt>)<ept id="4">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept> ... <bpt id="4" ctype="x-strong">&lt;strong></bpt>)<ept id="4">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept> ... <bpt id="4" ctype="x-strong">&lt;strong></bpt>)<ept id="4">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="225">
<source xml:lang="en">Named capturing group. Can be later referenced by name as well as by number. Avoid using the name "DEFINE" (see "conditional patterns").</source>
<seg-source><mrk mid="0" mtype="seg">Named capturing group.</mrk> <mrk mid="1" mtype="seg">Can be later referenced by name as well as by number.</mrk> <mrk mid="2" mtype="seg">Avoid using the name "DEFINE" (see "conditional patterns").</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Named capturing group.</mrk> <mrk mid="1" mtype="seg">Can be later referenced by name as well as by number.</mrk> <mrk mid="2" mtype="seg">Avoid using the name "DEFINE" (see "conditional patterns").</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="226">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?:<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?:<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?:<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="227">
<source xml:lang="en">Non-capturing group. Does not record the matching characters in the array and cannot be re-used as backreference.</source>
<seg-source><mrk mid="0" mtype="seg">Non-capturing group.</mrk> <mrk mid="1" mtype="seg">Does not record the matching characters in the array and cannot be re-used as backreference.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Non-capturing group.</mrk> <mrk mid="1" mtype="seg">Does not record the matching characters in the array and cannot be re-used as backreference.</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="228">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?|<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?|<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?|<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="229">
<source xml:lang="en">Non-capturing group with reset. Resets capturing group numbers in each top-level alternative it contains: "(?|(Mon)|(Tue)s|(Wed)nes|(Thu)rs|(Fri)|(Sat)ur|(Sun))day" matches a weekday name and captures its abbreviation in group number 1.</source>
<seg-source><mrk mid="0" mtype="seg">Non-capturing group with reset.</mrk> <mrk mid="1" mtype="seg">Resets capturing group numbers in each top-level alternative it contains:</mrk> <mrk mid="2" mtype="seg">"(?|(Mon)|(Tue)s|(Wed)nes|(Thu)rs|(Fri)|(Sat)ur|(Sun))day" matches a weekday name and captures its abbreviation in group number 1.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Non-capturing group with reset.</mrk> <mrk mid="1" mtype="seg">Resets capturing group numbers in each top-level alternative it contains:</mrk> <mrk mid="2" mtype="seg">"(?|(Mon)|(Tue)s|(Wed)nes|(Thu)rs|(Fri)|(Sat)ur|(Sun))day" matches a weekday name and captures its abbreviation in group number 1.</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="230">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?><ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?><ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?><ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="231">
<source xml:lang="en">Atomic non-capturing group: locks and never backtracks into (gives back from) what has been matched (see also Quantifiers and greediness below). Atomic groups, like possessive quantifiers, are always greedy.</source>
<seg-source><mrk mid="0" mtype="seg">Atomic non-capturing group: locks and never backtracks into (gives back from) what has been matched (see also Quantifiers and greediness below).</mrk> <mrk mid="1" mtype="seg">Atomic groups, like possessive quantifiers, are always greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Atomic non-capturing group: locks and never backtracks into (gives back from) what has been matched (see also Quantifiers and greediness below).</mrk> <mrk mid="1" mtype="seg">Atomic groups, like possessive quantifiers, are always greedy.</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="232">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?#<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?#<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?#<ept id="1">&lt;/strong></ept> ... <bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="233">
<source xml:lang="en">Comment group: always ignored (but may not contain a closing parenthesis, hence comment groups are not nestable).</source>
<seg-source><mrk mid="0" mtype="seg">Comment group: always ignored (but may not contain a closing parenthesis, hence comment groups are not nestable).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Comment group: always ignored (but may not contain a closing parenthesis, hence comment groups are not nestable).</mrk></target>
<note> ... </note>
</trans-unit>
<trans-unit id="234">
<source xml:lang="en"> Quantifiers (or repetition specifiers) specify how many of the preceding character, class, reference or group are expected to match. Optional greediness qualifiers denote how aggressively the repetition will behave. For instance "\d{3,5}" will match at least 3 and no more than 5 decimal digits.</source>
<seg-source> <mrk mid="0" mtype="seg">Quantifiers (or repetition specifiers) specify how many of the preceding character, class, reference or group are expected to match.</mrk> <mrk mid="1" mtype="seg">Optional greediness qualifiers denote how aggressively the repetition will behave.</mrk> <mrk mid="2" mtype="seg">For instance "\d{3,5}" will match at least 3 and no more than 5 decimal digits.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Quantifiers (or repetition specifiers) specify how many of the preceding character, class, reference or group are expected to match.</mrk> <mrk mid="1" mtype="seg">Optional greediness qualifiers denote how aggressively the repetition will behave.</mrk> <mrk mid="2" mtype="seg">For instance "\d{3,5}" will match at least 3 and no more than 5 decimal digits.</mrk></target>
</trans-unit>
<trans-unit id="235">
<source xml:lang="en"> By default, patterns are "<bpt id="1" ctype="x-u">&lt;u></bpt>greedy<ept id="1">&lt;/u></ept>", which means that quantifiers <it id="2" ctype="x-strong" pos="open">&lt;strong></it>* + ? {<it id="2" ctype="x-strong" pos="close">&lt;/strong></it>...<bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept> will match the longest string which doesn't cause the rest of the pattern to fail. Greediness can be inverted for the entire pattern by giving option (?U) at the head of the pattern, or locally by placing a question mark following a quantifier.</source>
<seg-source> <mrk mid="0" mtype="seg">By default, patterns are "<bpt id="1" ctype="x-u">&lt;u></bpt>greedy<ept id="1">&lt;/u></ept>", which means that quantifiers <it id="2" ctype="x-strong" pos="open">&lt;strong></it>* + ?</mrk> <mrk mid="1" mtype="seg">{<it id="2" ctype="x-strong" pos="close">&lt;/strong></it>...<bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept> will match the longest string which doesn't cause the rest of the pattern to fail.</mrk> <mrk mid="2" mtype="seg">Greediness can be inverted for the entire pattern by giving option (?</mrk><mrk mid="3" mtype="seg">U) at the head of the pattern, or locally by placing a question mark following a quantifier.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">By default, patterns are "<bpt id="1" ctype="x-u">&lt;u></bpt>greedy<ept id="1">&lt;/u></ept>", which means that quantifiers <it id="2" ctype="x-strong" pos="open">&lt;strong></it>* + ?</mrk> <mrk mid="1" mtype="seg">{<it id="2" ctype="x-strong" pos="close">&lt;/strong></it>...<bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept> will match the longest string which doesn't cause the rest of the pattern to fail.</mrk> <mrk mid="2" mtype="seg">Greediness can be inverted for the entire pattern by giving option (?</mrk><mrk mid="3" mtype="seg">U) at the head of the pattern, or locally by placing a question mark following a quantifier.</mrk></target>
</trans-unit>
<trans-unit id="236">
<source xml:lang="en"> Non-greedy (<bpt id="1" ctype="x-u">&lt;u></bpt>lazy<ept id="1">&lt;/u></ept>) repetitions will match the smallest string that still allows the rest of the pattern to match. E.g. given the subject "aaab", the pattern "(a*)([ab]+)" will capture "aaa" then "b", but "(?U)(a*)([ab]+)" will capture "" then "a": indeed, capturing an empty string is good enough to satisfy the lazy "(a*)" and capturing "a" matches the lazy "([ab]+)" subpattern.</source>
<seg-source> <mrk mid="0" mtype="seg">Non-greedy (<bpt id="1" ctype="x-u">&lt;u></bpt>lazy<ept id="1">&lt;/u></ept>) repetitions will match the smallest string that still allows the rest of the pattern to match.</mrk> <mrk mid="1" mtype="seg">E.g. given the subject "aaab", the pattern "(a*)([ab]+)" will capture "aaa" then "b", but "(?</mrk><mrk mid="2" mtype="seg">U)(a*)([ab]+)" will capture "" then "a": indeed, capturing an empty string is good enough to satisfy the lazy "(a*)" and capturing "a" matches the lazy "([ab]+)" subpattern.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Non-greedy (<bpt id="1" ctype="x-u">&lt;u></bpt>lazy<ept id="1">&lt;/u></ept>) repetitions will match the smallest string that still allows the rest of the pattern to match.</mrk> <mrk mid="1" mtype="seg">E.g. given the subject "aaab", the pattern "(a*)([ab]+)" will capture "aaa" then "b", but "(?</mrk><mrk mid="2" mtype="seg">U)(a*)([ab]+)" will capture "" then "a": indeed, capturing an empty string is good enough to satisfy the lazy "(a*)" and capturing "a" matches the lazy "([ab]+)" subpattern.</mrk></target>
</trans-unit>
<trans-unit id="237">
<source xml:lang="en"> Possessive quantifiers are atomic and greedy. In fact they are a short notation for simple atomic groups. "\d++" is a shorthand notation for "(?>\d+)" and its behavior is "match a complete sequence of one or more digits, but never give back any". As a consequence "\d++<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d<ept id="1">&lt;/strong></ept>)" can never match since the last digit (in bold) is already matched and locked by "\d++". This is in contrast with simple greediness, where "\d+(\d)" will first match a complete sequence of digits with "\d+", but then backtrack the last one to allow "<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d)<ept id="1">&lt;/strong></ept>" to capture it.</source>
<seg-source> <mrk mid="0" mtype="seg">Possessive quantifiers are atomic and greedy.</mrk> <mrk mid="1" mtype="seg">In fact they are a short notation for simple atomic groups.</mrk> <mrk mid="2" mtype="seg">"\d++" is a shorthand notation for "(?>\d+)" and its behavior is "match a complete sequence of one or more digits, but never give back any".</mrk> <mrk mid="3" mtype="seg">As a consequence "\d++<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d<ept id="1">&lt;/strong></ept>)" can never match since the last digit (in bold) is already matched and locked by "\d++".</mrk> <mrk mid="4" mtype="seg">This is in contrast with simple greediness, where "\d+(\d)" will first match a complete sequence of digits with "\d+", but then backtrack the last one to allow "<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d)<ept id="1">&lt;/strong></ept>" to capture it.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Possessive quantifiers are atomic and greedy.</mrk> <mrk mid="1" mtype="seg">In fact they are a short notation for simple atomic groups.</mrk> <mrk mid="2" mtype="seg">"\d++" is a shorthand notation for "(?>\d+)" and its behavior is "match a complete sequence of one or more digits, but never give back any".</mrk> <mrk mid="3" mtype="seg">As a consequence "\d++<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d<ept id="1">&lt;/strong></ept>)" can never match since the last digit (in bold) is already matched and locked by "\d++".</mrk> <mrk mid="4" mtype="seg">This is in contrast with simple greediness, where "\d+(\d)" will first match a complete sequence of digits with "\d+", but then backtrack the last one to allow "<bpt id="1" ctype="x-strong">&lt;strong></bpt>(\d)<ept id="1">&lt;/strong></ept>" to capture it.</mrk></target>
</trans-unit>
<trans-unit id="238">
<source xml:lang="en"> There are two reasons for using an atomic group or a possessive quantifier: either for matching a sequence of characters that may also appear individually (e.g. "\r\n" in the definition of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept>), or for forcing a quick failure in certain situations involving unbounded repetitions, where the engine would normally spend a very long time trying a huge number of grouping combinations before failing.</source>
<seg-source> <mrk mid="0" mtype="seg">There are two reasons for using an atomic group or a possessive quantifier: either for matching a sequence of characters that may also appear individually (e.g.</mrk> <mrk mid="1" mtype="seg">"\r\n" in the definition of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept>), or for forcing a quick failure in certain situations involving unbounded repetitions, where the engine would normally spend a very long time trying a huge number of grouping combinations before failing.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">There are two reasons for using an atomic group or a possessive quantifier: either for matching a sequence of characters that may also appear individually (e.g.</mrk> <mrk mid="1" mtype="seg">"\r\n" in the definition of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\R<ept id="1">&lt;/strong></ept>), or for forcing a quick failure in certain situations involving unbounded repetitions, where the engine would normally spend a very long time trying a huge number of grouping combinations before failing.</mrk></target>
</trans-unit>
<trans-unit id="239">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="240">
<source xml:lang="en">0 or 1, greedy.</source>
<seg-source><mrk mid="0" mtype="seg">0 or 1, greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or 1, greedy.</mrk></target>
</trans-unit>
<trans-unit id="241">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?+<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?+<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>?+<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="242">
<source xml:lang="en">0 or 1, possessive.</source>
<seg-source><mrk mid="0" mtype="seg">0 or 1, possessive.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or 1, possessive.</mrk></target>
</trans-unit>
<trans-unit id="243">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>??<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>??<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>??<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="244">
<source xml:lang="en">0 or 1, lazy.</source>
<seg-source><mrk mid="0" mtype="seg">0 or 1, lazy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or 1, lazy.</mrk></target>
</trans-unit>
<trans-unit id="245">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="246">
<source xml:lang="en">0 or more, greedy.</source>
<seg-source><mrk mid="0" mtype="seg">0 or more, greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or more, greedy.</mrk></target>
</trans-unit>
<trans-unit id="247">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*+<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*+<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*+<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="248">
<source xml:lang="en">0 or more, possessive.</source>
<seg-source><mrk mid="0" mtype="seg">0 or more, possessive.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or more, possessive.</mrk></target>
</trans-unit>
<trans-unit id="249">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*?<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*?<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>*?<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="250">
<source xml:lang="en">0 or more, lazy.</source>
<seg-source><mrk mid="0" mtype="seg">0 or more, lazy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">0 or more, lazy.</mrk></target>
</trans-unit>
<trans-unit id="251">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="252">
<source xml:lang="en">1 or more, greedy.</source>
<seg-source><mrk mid="0" mtype="seg">1 or more, greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">1 or more, greedy.</mrk></target>
</trans-unit>
<trans-unit id="253">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>++<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>++<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>++<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="254">
<source xml:lang="en">1 or more, possessive.</source>
<seg-source><mrk mid="0" mtype="seg">1 or more, possessive.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">1 or more, possessive.</mrk></target>
</trans-unit>
<trans-unit id="255">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+?<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+?<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>+?<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="256">
<source xml:lang="en">1 or more, lazy.</source>
<seg-source><mrk mid="0" mtype="seg">1 or more, lazy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">1 or more, lazy.</mrk></target>
</trans-unit>
<trans-unit id="257">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="258">
<source xml:lang="en">exactly <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">exactly <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">exactly <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="259">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}<ept id="5">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}<ept id="5">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}<ept id="5">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="260">
<source xml:lang="en">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, greedy.</source>
<seg-source><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, greedy.</mrk></target>
</trans-unit>
<trans-unit id="261">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}+<ept id="5">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}+<ept id="5">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}+<ept id="5">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="262">
<source xml:lang="en">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, possessive.</source>
<seg-source><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, possessive.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, possessive.</mrk></target>
</trans-unit>
<trans-unit id="263">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}?<ept id="5">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}?<ept id="5">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>y<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>}?<ept id="5">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="264">
<source xml:lang="en">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, lazy.</source>
<seg-source><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, lazy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">at least <bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> and no more than <bpt id="2" ctype="x-em">&lt;em></bpt>y<ept id="2">&lt;/em></ept>, lazy.</mrk></target>
</trans-unit>
<trans-unit id="265">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="266">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, greedy.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, greedy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, greedy.</mrk></target>
</trans-unit>
<trans-unit id="267">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}+<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}+<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}+<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="268">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, possessive.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, possessive.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, possessive.</mrk></target>
</trans-unit>
<trans-unit id="269">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}?<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}?<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>x<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>,}?<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="270">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, lazy.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, lazy.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>x<ept id="1">&lt;/em></ept> or more, lazy.</mrk></target>
</trans-unit>
<trans-unit id="271">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>|<ept id="2">&lt;/strong></ept><bpt id="3" ctype="x-em">&lt;em></bpt>Y<ept id="3">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>|<ept id="2">&lt;/strong></ept><bpt id="3" ctype="x-em">&lt;em></bpt>Y<ept id="3">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>|<ept id="2">&lt;/strong></ept><bpt id="3" ctype="x-em">&lt;em></bpt>Y<ept id="3">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="272">
<source xml:lang="en">Matches either subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> or <bpt id="2" ctype="x-em">&lt;em></bpt>Y<ept id="2">&lt;/em></ept>: "ac|dc|ground" matches "ac" or "dc" or "ground".</source>
<seg-source><mrk mid="0" mtype="seg">Matches either subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> or <bpt id="2" ctype="x-em">&lt;em></bpt>Y<ept id="2">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"ac|dc|ground" matches "ac" or "dc" or "ground".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches either subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> or <bpt id="2" ctype="x-em">&lt;em></bpt>Y<ept id="2">&lt;/em></ept>:</mrk> <mrk mid="1" mtype="seg">"ac|dc|ground" matches "ac" or "dc" or "ground".</mrk></target>
</trans-unit>
<trans-unit id="273">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Backreferences<ept id="1">&lt;/strong></ept> permit reuse of the content of a previously captured group.</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Backreferences<ept id="1">&lt;/strong></ept> permit reuse of the content of a previously captured group.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Backreferences<ept id="1">&lt;/strong></ept> permit reuse of the content of a previously captured group.</mrk></target>
</trans-unit>
<trans-unit id="274">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="275">
<source xml:lang="en">References a previous capturing group by its absolute number. WARNING: if no group number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> exists, it evaluates as the character with value <bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept> provided <bpt id="3" ctype="x-em">&lt;em></bpt>n<ept id="3">&lt;/em></ept> is a valid octal value, else errors out.</source>
<seg-source><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk> <mrk mid="1" mtype="seg">WARNING: if no group number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> exists, it evaluates as the character with value <bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept> provided <bpt id="3" ctype="x-em">&lt;em></bpt>n<ept id="3">&lt;/em></ept> is a valid octal value, else errors out.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk> <mrk mid="1" mtype="seg">WARNING: if no group number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> exists, it evaluates as the character with value <bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept> provided <bpt id="3" ctype="x-em">&lt;em></bpt>n<ept id="3">&lt;/em></ept> is a valid octal value, else errors out.</mrk></target>
</trans-unit>
<trans-unit id="276">
<source xml:lang="en"> Due to this ambiguity, this form is not recommended. Favor the next forms for a safe semantic.</source>
<seg-source> <mrk mid="0" mtype="seg">Due to this ambiguity, this form is not recommended.</mrk> <mrk mid="1" mtype="seg">Favor the next forms for a safe semantic.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Due to this ambiguity, this form is not recommended.</mrk> <mrk mid="1" mtype="seg">Favor the next forms for a safe semantic.</mrk></target>
</trans-unit>
<trans-unit id="277">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="278">
<source xml:lang="en">References a previous capturing group by its absolute number.</source>
<seg-source><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk></target>
</trans-unit>
<trans-unit id="279">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g{<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>}<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="280">
<source xml:lang="en">References a previous capturing group by its absolute number. Similar to above but clearly delimits where <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> ends: useful when the following character(s) is(are) digits.</source>
<seg-source><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk> <mrk mid="1" mtype="seg">Similar to above but clearly delimits where <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> ends: useful when the following character(s) is(are) digits.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">References a previous capturing group by its absolute number.</mrk> <mrk mid="1" mtype="seg">Similar to above but clearly delimits where <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> ends: useful when the following character(s) is(are) digits.</mrk></target>
</trans-unit>
<trans-unit id="281">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\g-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="282">
<source xml:lang="en">References a previous capturing group by its relative number.</source>
<seg-source><mrk mid="0" mtype="seg">References a previous capturing group by its relative number.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">References a previous capturing group by its relative number.</mrk></target>
</trans-unit>
<trans-unit id="283">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\k&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\k&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\k&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>><ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="284">
<source xml:lang="en">References a previous capturing group by its name.</source>
<seg-source><mrk mid="0" mtype="seg">References a previous capturing group by its name.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">References a previous capturing group by its name.</mrk></target>
</trans-unit>
<trans-unit id="285">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>References to subroutines<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>References to subroutines<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>References to subroutines<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="286">
<source xml:lang="en"> Capturing groups are subpatterns that can be invoked (possibly recursively) exactly like subroutines in a programming language. The subpattern is simply re-run at the current matching point. See reference documentation for details and examples.</source>
<seg-source> <mrk mid="0" mtype="seg">Capturing groups are subpatterns that can be invoked (possibly recursively) exactly like subroutines in a programming language.</mrk> <mrk mid="1" mtype="seg">The subpattern is simply re-run at the current matching point.</mrk> <mrk mid="2" mtype="seg">See reference documentation for details and examples.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Capturing groups are subpatterns that can be invoked (possibly recursively) exactly like subroutines in a programming language.</mrk> <mrk mid="1" mtype="seg">The subpattern is simply re-run at the current matching point.</mrk> <mrk mid="2" mtype="seg">See reference documentation for details and examples.</mrk></target>
</trans-unit>
<trans-unit id="287">
<source xml:lang="en"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?R)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(?0)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">R)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(?0)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">R)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(?0)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="288">
<source xml:lang="en">Recurses into the entire regular expression.</source>
<seg-source><mrk mid="0" mtype="seg">Recurses into the entire regular expression.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Recurses into the entire regular expression.</mrk></target>
<note> or </note>
</trans-unit>
<trans-unit id="289">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="290">
<source xml:lang="en">Calls subpattern by absolute number.</source>
<seg-source><mrk mid="0" mtype="seg">Calls subpattern by absolute number.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Calls subpattern by absolute number.</mrk></target>
</trans-unit>
<trans-unit id="291">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="292">
<source xml:lang="en">Calls subpattern by relative number.</source>
<seg-source><mrk mid="0" mtype="seg">Calls subpattern by relative number.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Calls subpattern by relative number.</mrk></target>
</trans-unit>
<trans-unit id="293">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="294">
<source xml:lang="en">Calls subpattern by relative number.</source>
<seg-source><mrk mid="0" mtype="seg">Calls subpattern by relative number.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Calls subpattern by relative number.</mrk></target>
</trans-unit>
<trans-unit id="295">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="296">
<source xml:lang="en">Calls subpattern by name.</source>
<seg-source><mrk mid="0" mtype="seg">Calls subpattern by name.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Calls subpattern by name.</mrk></target>
</trans-unit>
<trans-unit id="297">
<source xml:lang="en"> Anchors and assertions are tests that do not change the matching position and therefore do not consume nor capture anything.</source>
<seg-source> <mrk mid="0" mtype="seg">Anchors and assertions are tests that do not change the matching position and therefore do not consume nor capture anything.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Anchors and assertions are tests that do not change the matching position and therefore do not consume nor capture anything.</mrk></target>
</trans-unit>
<trans-unit id="298">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Anchors<ept id="1">&lt;/strong></ept> test the position of the current matching point.</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Anchors<ept id="1">&lt;/strong></ept> test the position of the current matching point.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Anchors<ept id="1">&lt;/strong></ept> test the position of the current matching point.</mrk></target>
</trans-unit>
<trans-unit id="299">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="300">
<source xml:lang="en">Outside a character class, the caret matches at the start of the subject text, and also just after a non-final newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active. By default the newline sequence is @CRLF.</source>
<seg-source><mrk mid="0" mtype="seg">Outside a character class, the caret matches at the start of the subject text, and also just after a non-final newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active.</mrk> <mrk mid="1" mtype="seg">By default the newline sequence is @CRLF.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Outside a character class, the caret matches at the start of the subject text, and also just after a non-final newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active.</mrk> <mrk mid="1" mtype="seg">By default the newline sequence is @CRLF.</mrk></target>
</trans-unit>
<trans-unit id="301">
<source xml:lang="en"> Inside a character class, a leading <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> complements the class (excludes the characters listed there).</source>
<seg-source> <mrk mid="0" mtype="seg">Inside a character class, a leading <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> complements the class (excludes the characters listed there).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Inside a character class, a leading <bpt id="1" ctype="x-strong">&lt;strong></bpt>^<ept id="1">&lt;/strong></ept> complements the class (excludes the characters listed there).</mrk></target>
</trans-unit>
<trans-unit id="302">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="303">
<source xml:lang="en">Outside a character class, the dollar matches at the end of the subject text, and also just before a newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active.</source>
<seg-source><mrk mid="0" mtype="seg">Outside a character class, the dollar matches at the end of the subject text, and also just before a newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Outside a character class, the dollar matches at the end of the subject text, and also just before a newline sequence if option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept> is active.</mrk></target>
</trans-unit>
<trans-unit id="304">
<source xml:lang="en"> Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept> means itself, a dollar sign.</source>
<seg-source> <mrk mid="0" mtype="seg">Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept> means itself, a dollar sign.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>$<ept id="1">&lt;/strong></ept> means itself, a dollar sign.</mrk></target>
</trans-unit>
<trans-unit id="305">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\A<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\A<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\A<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="306">
<source xml:lang="en">Matches only at the absolute beginning of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>. Will never match if offset is not 1.</source>
<seg-source><mrk mid="0" mtype="seg">Matches only at the absolute beginning of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">Will never match if offset is not 1.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches only at the absolute beginning of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">Will never match if offset is not 1.</mrk></target>
</trans-unit>
<trans-unit id="307">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\G<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\G<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\G<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="308">
<source xml:lang="en">Matches when the current position is the first matching position in subject.</source>
<seg-source><mrk mid="0" mtype="seg">Matches when the current position is the first matching position in subject.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches when the current position is the first matching position in subject.</mrk></target>
</trans-unit>
<trans-unit id="309">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\z<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\z<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\z<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="310">
<source xml:lang="en">Matches only at end of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Matches only at end of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches only at end of subject string, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="311">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Z<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Z<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\Z<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="312">
<source xml:lang="en">Matches only at end of subject string, or before a newline sequence at the end, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Matches only at end of subject string, or before a newline sequence at the end, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches only at end of subject string, or before a newline sequence at the end, irrespective of the multiline option <bpt id="1" ctype="x-strong">&lt;strong></bpt>(?m)<ept id="1">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="313">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Assertions<ept id="1">&lt;/strong></ept> test the character(s) preceding (look-behind), at (word boundary) or following (look-ahead) the current matching point.</source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Assertions<ept id="1">&lt;/strong></ept> test the character(s) preceding (look-behind), at (word boundary) or following (look-ahead) the current matching point.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Assertions<ept id="1">&lt;/strong></ept> test the character(s) preceding (look-behind), at (word boundary) or following (look-ahead) the current matching point.</mrk></target>
</trans-unit>
<trans-unit id="314">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="315">
<source xml:lang="en">Matches at a "word" boundary, i.e. between characters not both <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>\W<ept id="2">&lt;/strong></ept>. See <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> for the meaning of "word". Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept> means "backspace" (Chr(8)).</source>
<seg-source><mrk mid="0" mtype="seg">Matches at a "word" boundary, i.e. between characters not both <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>\W<ept id="2">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">See <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> for the meaning of "word".</mrk> <mrk mid="2" mtype="seg">Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept> means "backspace" (Chr(8)).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches at a "word" boundary, i.e. between characters not both <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>\W<ept id="2">&lt;/strong></ept>.</mrk> <mrk mid="1" mtype="seg">See <bpt id="1" ctype="x-strong">&lt;strong></bpt>\w<ept id="1">&lt;/strong></ept> for the meaning of "word".</mrk> <mrk mid="2" mtype="seg">Inside a character class, <bpt id="1" ctype="x-strong">&lt;strong></bpt>\b<ept id="1">&lt;/strong></ept> means "backspace" (Chr(8)).</mrk></target>
</trans-unit>
<trans-unit id="316">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\B<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\B<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\B<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="317">
<source xml:lang="en">Matches when not at a word boundary.</source>
<seg-source><mrk mid="0" mtype="seg">Matches when not at a word boundary.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Matches when not at a word boundary.</mrk></target>
</trans-unit>
<trans-unit id="318">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="319">
<source xml:lang="en">Positive look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches starting at the current position.</source>
<seg-source><mrk mid="0" mtype="seg">Positive look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches starting at the current position.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Positive look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches starting at the current position.</mrk></target>
</trans-unit>
<trans-unit id="320">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?!<ept id="1">&lt;/strong></ept><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?!<ept id="1">&lt;/strong></ept></mrk><mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?!<ept id="1">&lt;/strong></ept></mrk><mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="321">
<source xml:lang="en">Negative look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match starting at the current position.</source>
<seg-source><mrk mid="0" mtype="seg">Negative look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match starting at the current position.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Negative look-ahead: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match starting at the current position.</mrk></target>
</trans-unit>
<trans-unit id="322">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>X<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="323">
<source xml:lang="en">Positive look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches characters preceding the current position. Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Positive look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches characters preceding the current position.</mrk> <mrk mid="1" mtype="seg">Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Positive look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> matches characters preceding the current position.</mrk> <mrk mid="1" mtype="seg">Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="324">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;!<ept id="1">&lt;/strong></ept><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;!<ept id="1">&lt;/strong></ept></mrk><mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?&lt;!<ept id="1">&lt;/strong></ept></mrk><mrk mid="1" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept><bpt id="2" ctype="x-strong">&lt;strong></bpt>)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="325">
<source xml:lang="en">Negative look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match characters preceding the current position. Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Negative look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match characters preceding the current position.</mrk> <mrk mid="1" mtype="seg">Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Negative look-behind: matches when the subpattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> does not match characters preceding the current position.</mrk> <mrk mid="1" mtype="seg">Pattern <bpt id="1" ctype="x-em">&lt;em></bpt>X<ept id="1">&lt;/em></ept> must match a fixed-length string, i.e. may not use any undefinite quantifier <bpt id="2" ctype="x-strong">&lt;strong></bpt>* + or ?<ept id="2">&lt;/strong></ept>.</mrk></target>
</trans-unit>
<trans-unit id="326">
<source xml:lang="en"> There are situations where it is necessary to "forget" that something has matched so far, in order to match more pertinent data later in the subject string.</source>
<seg-source> <mrk mid="0" mtype="seg">There are situations where it is necessary to "forget" that something has matched so far, in order to match more pertinent data later in the subject string.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">There are situations where it is necessary to "forget" that something has matched so far, in order to match more pertinent data later in the subject string.</mrk></target>
</trans-unit>
<trans-unit id="327">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="328">
<source xml:lang="en">Resets start of match at the current point in subject string. Note that groups already captured are left alone and still populate the returned array; it is therefore always possible to backreference to them later on. Action of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept> is similar but not identical to a look-behind, in that <bpt id="2" ctype="x-strong">&lt;strong></bpt>\K<ept id="2">&lt;/strong></ept> can work on alternations of varying lengths.</source>
<seg-source><mrk mid="0" mtype="seg">Resets start of match at the current point in subject string.</mrk> <mrk mid="1" mtype="seg">Note that groups already captured are left alone and still populate the returned array; it is therefore always possible to backreference to them later on.</mrk> <mrk mid="2" mtype="seg">Action of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept> is similar but not identical to a look-behind, in that <bpt id="2" ctype="x-strong">&lt;strong></bpt>\K<ept id="2">&lt;/strong></ept> can work on alternations of varying lengths.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Resets start of match at the current point in subject string.</mrk> <mrk mid="1" mtype="seg">Note that groups already captured are left alone and still populate the returned array; it is therefore always possible to backreference to them later on.</mrk> <mrk mid="2" mtype="seg">Action of <bpt id="1" ctype="x-strong">&lt;strong></bpt>\K<ept id="1">&lt;/strong></ept> is similar but not identical to a look-behind, in that <bpt id="2" ctype="x-strong">&lt;strong></bpt>\K<ept id="2">&lt;/strong></ept> can work on alternations of varying lengths.</mrk></target>
</trans-unit>
<trans-unit id="329">
<source xml:lang="en"> These constructs are similar to <it id="1" ctype="x-strong" pos="open">&lt;strong></it><it id="2" ctype="x-em" pos="open">&lt;em></it>If...EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> and <it id="3" ctype="x-strong" pos="open">&lt;strong></it><it id="4" ctype="x-em" pos="open">&lt;em></it>If...Else...EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> blocks.</source>
<seg-source> <mrk mid="0" mtype="seg">These constructs are similar to <it id="1" ctype="x-strong" pos="open">&lt;strong></it><it id="2" ctype="x-em" pos="open">&lt;em></it>If...</mrk><mrk mid="1" mtype="seg">EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> and <it id="3" ctype="x-strong" pos="open">&lt;strong></it><it id="4" ctype="x-em" pos="open">&lt;em></it>If...</mrk><mrk mid="2" mtype="seg">Else...</mrk><mrk mid="3" mtype="seg">EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> blocks.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">These constructs are similar to <it id="1" ctype="x-strong" pos="open">&lt;strong></it><it id="2" ctype="x-em" pos="open">&lt;em></it>If...</mrk><mrk mid="1" mtype="seg">EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> and <it id="3" ctype="x-strong" pos="open">&lt;strong></it><it id="4" ctype="x-em" pos="open">&lt;em></it>If...</mrk><mrk mid="2" mtype="seg">Else...</mrk><mrk mid="3" mtype="seg">EndIf<it id="2" ctype="x-em" pos="close">&lt;/em></it><it id="1" ctype="x-strong" pos="close">&lt;/strong></it> blocks.</mrk></target>
</trans-unit>
<trans-unit id="330">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="331">
<source xml:lang="en">Allows conditional execution of pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Allows conditional execution of pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Allows conditional execution of pattern.</mrk></target>
</trans-unit>
<trans-unit id="332">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>|<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>no-pattern<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>)<ept id="5">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>|<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>no-pattern<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>)<ept id="5">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(?<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>(condition)yes-pattern<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>|<ept id="3">&lt;/strong></ept><bpt id="4" ctype="x-em">&lt;em></bpt>no-pattern<ept id="4">&lt;/em></ept><bpt id="5" ctype="x-strong">&lt;strong></bpt>)<ept id="5">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="333">
<source xml:lang="en">Chooses between distinct patterns depending on the result of <bpt id="1" ctype="x-em">&lt;em></bpt>(condition)<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Chooses between distinct patterns depending on the result of <bpt id="1" ctype="x-em">&lt;em></bpt>(condition)<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Chooses between distinct patterns depending on the result of <bpt id="1" ctype="x-em">&lt;em></bpt>(condition)<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="334">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="335">
<source xml:lang="en">Tests whether the capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> matched.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> matched.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> matched.</mrk></target>
</trans-unit>
<trans-unit id="336">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(+<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="337">
<source xml:lang="en">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>+n<ept id="1">&lt;/em></ept> matched.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>+n<ept id="1">&lt;/em></ept> matched.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>+n<ept id="1">&lt;/em></ept> matched.</mrk></target>
</trans-unit>
<trans-unit id="338">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(-<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="339">
<source xml:lang="en">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>-n<ept id="1">&lt;/em></ept> matched.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>-n<ept id="1">&lt;/em></ept> matched.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the capturing group with relative number <bpt id="1" ctype="x-em">&lt;em></bpt>-n<ept id="1">&lt;/em></ept> matched.</mrk></target>
</trans-unit>
<trans-unit id="340">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(&lt;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="341">
<source xml:lang="en">Tests whether the capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept> matched.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept> matched.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept> matched.</mrk></target>
</trans-unit>
<trans-unit id="342">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="343">
<source xml:lang="en">Tests whether any kind of recursion occured.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether any kind of recursion occured.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether any kind of recursion occured.</mrk></target>
</trans-unit>
<trans-unit id="344">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="345">
<source xml:lang="en">Tests whether the most recent recursion was for capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the most recent recursion was for capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the most recent recursion was for capturing group with absolute number <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="346">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(R&amp;<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="347">
<source xml:lang="en">Tests whether the most recent recursion was for capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Tests whether the most recent recursion was for capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tests whether the most recent recursion was for capturing group with name <bpt id="1" ctype="x-em">&lt;em></bpt>name<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="348">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(DEFINE)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(DEFINE)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(DEFINE)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="349">
<source xml:lang="en">Used without <bpt id="1" ctype="x-em">&lt;em></bpt>no-pattern<ept id="1">&lt;/em></ept>, permits definition of a subroutine useable from elsewhere. "(?x) (?(DEFINE) (?&lt;byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )" defines a subroutine named "byte" which matches any component of an IPv4 address. Then an actual address can be matched by "\b (?&amp;byte) (\.(?&amp;byte)){3} \b".</source>
<seg-source><mrk mid="0" mtype="seg">Used without <bpt id="1" ctype="x-em">&lt;em></bpt>no-pattern<ept id="1">&lt;/em></ept>, permits definition of a subroutine useable from elsewhere.</mrk> <mrk mid="1" mtype="seg">"(?x) (?(DEFINE) (?&lt;byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )" defines a subroutine named "byte" which matches any component of an IPv4 address.</mrk> <mrk mid="2" mtype="seg">Then an actual address can be matched by "\b (?&amp;byte) (\.(?&amp;byte)){3} \b".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Used without <bpt id="1" ctype="x-em">&lt;em></bpt>no-pattern<ept id="1">&lt;/em></ept>, permits definition of a subroutine useable from elsewhere.</mrk> <mrk mid="1" mtype="seg">"(?x) (?(DEFINE) (?&lt;byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )" defines a subroutine named "byte" which matches any component of an IPv4 address.</mrk> <mrk mid="2" mtype="seg">Then an actual address can be matched by "\b (?&amp;byte) (\.(?&amp;byte)){3} \b".</mrk></target>
</trans-unit>
<trans-unit id="350">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>assertion<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>assertion<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>assertion<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="351">
<source xml:lang="en">Here <bpt id="1" ctype="x-em">&lt;em></bpt>assertion<ept id="1">&lt;/em></ept> is one of positive or negative, look-ahead or look-behind assertion.</source>
<seg-source><mrk mid="0" mtype="seg">Here <bpt id="1" ctype="x-em">&lt;em></bpt>assertion<ept id="1">&lt;/em></ept> is one of positive or negative, look-ahead or look-behind assertion.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Here <bpt id="1" ctype="x-em">&lt;em></bpt>assertion<ept id="1">&lt;/em></ept> is one of positive or negative, look-ahead or look-behind assertion.</mrk></target>
</trans-unit>
<trans-unit id="352">
<source xml:lang="en"> These options, escapes and constructs are simply mentioned here; see reference documentation for detail on why, when and how to use them, if at all.</source>
<seg-source> <mrk mid="0" mtype="seg">These options, escapes and constructs are simply mentioned here; see reference documentation for detail on why, when and how to use them, if at all.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">These options, escapes and constructs are simply mentioned here; see reference documentation for detail on why, when and how to use them, if at all.</mrk></target>
</trans-unit>
<trans-unit id="353">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Uncommon settings and options<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Uncommon settings and options<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Uncommon settings and options<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="354">
<source xml:lang="en"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?J)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">J)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">J)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></target>
</trans-unit>
<trans-unit id="355">
<source xml:lang="en">Enables duplicate group or subroutine names (not discussed further here).</source>
<seg-source><mrk mid="0" mtype="seg">Enables duplicate group or subroutine names (not discussed further here).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Enables duplicate group or subroutine names (not discussed further here).</mrk></target>
</trans-unit>
<trans-unit id="356">
<source xml:lang="en"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?X)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">X)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-strong" pos="open">&lt;strong></it>(?</mrk><mrk mid="1" mtype="seg">X)<it id="1" ctype="x-strong" pos="close">&lt;/strong></it></mrk></target>
</trans-unit>
<trans-unit id="357">
<source xml:lang="en">Causes some out-of-context sequences to raise an error, instead of being benign.</source>
<seg-source><mrk mid="0" mtype="seg">Causes some out-of-context sequences to raise an error, instead of being benign.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Causes some out-of-context sequences to raise an error, instead of being benign.</mrk></target>
</trans-unit>
<trans-unit id="358">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*J)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*J)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*J)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="359">
<source xml:lang="en">Enables Javascript compatibility (not discussed further here).</source>
<seg-source><mrk mid="0" mtype="seg">Enables Javascript compatibility (not discussed further here).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Enables Javascript compatibility (not discussed further here).</mrk></target>
</trans-unit>
<trans-unit id="360">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_MATCH=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_MATCH=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_MATCH=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="361">
<source xml:lang="en">Limits number of matches to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Limits number of matches to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Limits number of matches to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept>.</mrk></target>
</trans-unit>
<trans-unit id="362">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_RECURSION=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_RECURSION=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*LIMIT_RECURSION=<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>n<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="363">
<source xml:lang="en">Limits recursion to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> levels.</source>
<seg-source><mrk mid="0" mtype="seg">Limits recursion to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> levels.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Limits recursion to <bpt id="1" ctype="x-em">&lt;em></bpt>n<ept id="1">&lt;/em></ept> levels.</mrk></target>
</trans-unit>
<trans-unit id="364">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*NO_START_OPT)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*NO_START_OPT)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*NO_START_OPT)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="365">
<source xml:lang="en">Disables several optimizations (not discussed further here).</source>
<seg-source><mrk mid="0" mtype="seg">Disables several optimizations (not discussed further here).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Disables several optimizations (not discussed further here).</mrk></target>
</trans-unit>
<trans-unit id="366">
<source xml:lang="en"> <bpt id="1" ctype="x-strong">&lt;strong></bpt>Backtracking control<ept id="1">&lt;/strong></ept></source>
<seg-source> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Backtracking control<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>Backtracking control<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="367">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ACCEPT)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ACCEPT)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*ACCEPT)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="368">
<source xml:lang="en">Forces an immediate match success in the current subroutine or top-level pattern.</source>
<seg-source><mrk mid="0" mtype="seg">Forces an immediate match success in the current subroutine or top-level pattern.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Forces an immediate match success in the current subroutine or top-level pattern.</mrk></target>
</trans-unit>
<trans-unit id="369">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*FAIL)<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(*F)<ept id="2">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*FAIL)<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(*F)<ept id="2">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*FAIL)<ept id="1">&lt;/strong></ept> or <bpt id="2" ctype="x-strong">&lt;strong></bpt>(*F)<ept id="2">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="370">
<source xml:lang="en">Forces an immediate match failure.</source>
<seg-source><mrk mid="0" mtype="seg">Forces an immediate match failure.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Forces an immediate match failure.</mrk></target>
<note> or </note>
</trans-unit>
<trans-unit id="371">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*MARK:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept> or <bpt id="4" ctype="x-strong">&lt;strong></bpt>(*:<ept id="4">&lt;/strong></ept><bpt id="5" ctype="x-em">&lt;em></bpt>name<ept id="5">&lt;/em></ept><bpt id="6" ctype="x-strong">&lt;strong></bpt>)<ept id="6">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*MARK:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept> or <bpt id="4" ctype="x-strong">&lt;strong></bpt>(*:<ept id="4">&lt;/strong></ept><bpt id="5" ctype="x-em">&lt;em></bpt>name<ept id="5">&lt;/em></ept><bpt id="6" ctype="x-strong">&lt;strong></bpt>)<ept id="6">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*MARK:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept> or <bpt id="4" ctype="x-strong">&lt;strong></bpt>(*:<ept id="4">&lt;/strong></ept><bpt id="5" ctype="x-em">&lt;em></bpt>name<ept id="5">&lt;/em></ept><bpt id="6" ctype="x-strong">&lt;strong></bpt>)<ept id="6">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="372">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
<note> or </note>
</trans-unit>
<trans-unit id="373">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*COMMIT)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*COMMIT)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*COMMIT)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="374">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="375">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="376">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="377">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*PRUNE:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="378">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="379">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="380">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="381">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*SKIP:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="382">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="383">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN)<ept id="1">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN)<ept id="1">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN)<ept id="1">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="384">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="385">
<source xml:lang="en"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-strong">&lt;strong></bpt>(*THEN:<ept id="1">&lt;/strong></ept><bpt id="2" ctype="x-em">&lt;em></bpt>name<ept id="2">&lt;/em></ept><bpt id="3" ctype="x-strong">&lt;strong></bpt>)<ept id="3">&lt;/strong></ept></mrk></target>
</trans-unit>
<trans-unit id="386">
<source xml:lang="en"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-em">&lt;em></bpt>(See reference documentation.)<ept id="1">&lt;/em></ept></mrk></target>
</trans-unit>
<trans-unit id="387">
<source xml:lang="en">  1. When UCP is active, case sense matching applies to the full Unicode plane 0. There are also a small number of many-to-one mappings in Unicode, like the Greek lowercase letter sigma; these are supported by PCRE with UCP enabled.</source>
<seg-source> <mrk mid="0" mtype="seg"> 1.</mrk> <mrk mid="1" mtype="seg">When UCP is active, case sense matching applies to the full Unicode plane 0.</mrk> <mrk mid="2" mtype="seg">There are also a small number of many-to-one mappings in Unicode, like the Greek lowercase letter sigma; these are supported by PCRE with UCP enabled.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"> 1.</mrk> <mrk mid="1" mtype="seg">When UCP is active, case sense matching applies to the full Unicode plane 0.</mrk> <mrk mid="2" mtype="seg">There are also a small number of many-to-one mappings in Unicode, like the Greek lowercase letter sigma; these are supported by PCRE with UCP enabled.</mrk></target>
</trans-unit>
<trans-unit id="388">
<source xml:lang="en">  2. Alternate forms of several escapes exist for compatibility with Perl, Ruby, Python, JavaScript, .NET and other engines. Do not use constructs not listed here: some will simply not work, some will supply wrong results, some will cause severe issues or merely crash.</source>
<seg-source> <mrk mid="0" mtype="seg"> 2.</mrk> <mrk mid="1" mtype="seg">Alternate forms of several escapes exist for compatibility with Perl, Ruby, Python, JavaScript, .NET and other engines.</mrk> <mrk mid="2" mtype="seg">Do not use constructs not listed here: some will simply not work, some will supply wrong results, some will cause severe issues or merely crash.</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"> 2.</mrk> <mrk mid="1" mtype="seg">Alternate forms of several escapes exist for compatibility with Perl, Ruby, Python, JavaScript, .NET and other engines.</mrk> <mrk mid="2" mtype="seg">Do not use constructs not listed here: some will simply not work, some will supply wrong results, some will cause severe issues or merely crash.</mrk></target>
</trans-unit>
<trans-unit id="389">
<source xml:lang="en">  3. The default newline convention is the unbreakable sequence @CRLF or a separate @CR or @LF. Similarly \R matches the same set. Know your data! If you know that your subjects use separate @LF or @CR to mean something else than a newline, you may have to change the newline convention and/or the matching of \R (see "Settings").</source>
<seg-source> <mrk mid="0" mtype="seg"> 3.</mrk> <mrk mid="1" mtype="seg">The default newline convention is the unbreakable sequence @CRLF or a separate @CR or @LF.</mrk> <mrk mid="2" mtype="seg">Similarly \R matches the same set.</mrk> <mrk mid="3" mtype="seg">Know your data!</mrk> <mrk mid="4" mtype="seg">If you know that your subjects use separate @LF or @CR to mean something else than a newline, you may have to change the newline convention and/or the matching of \R (see "Settings").</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg"> 3.</mrk> <mrk mid="1" mtype="seg">The default newline convention is the unbreakable sequence @CRLF or a separate @CR or @LF.</mrk> <mrk mid="2" mtype="seg">Similarly \R matches the same set.</mrk> <mrk mid="3" mtype="seg">Know your data!</mrk> <mrk mid="4" mtype="seg">If you know that your subjects use separate @LF or @CR to mean something else than a newline, you may have to change the newline convention and/or the matching of \R (see "Settings").</mrk></target>
</trans-unit>
<trans-unit id="390">
<source xml:lang="en"> See also the <bpt id="1" ctype="x-a">&lt;a href="../tutorials/regexp/regexp.htm"></bpt>Regular Expression<ept id="1">&lt;/a></ept> tutorial, in which you can run a script to test your regular expression(s).</source>
<seg-source> <mrk mid="0" mtype="seg">See also the <bpt id="1" ctype="x-a">&lt;a href="../tutorials/regexp/regexp.htm"></bpt>Regular Expression<ept id="1">&lt;/a></ept> tutorial, in which you can run a script to test your regular expression(s).</mrk></seg-source>
<target xml:lang="fr"> <mrk mid="0" mtype="seg">See also the <bpt id="1" ctype="x-a">&lt;a href="../tutorials/regexp/regexp.htm"></bpt>Regular Expression<ept id="1">&lt;/a></ept> tutorial, in which you can run a script to test your regular expression(s).</mrk></target>
</trans-unit>
<trans-unit id="391">
<source xml:lang="en">Related</source>
<seg-source><mrk mid="0" mtype="seg">Related</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Related</mrk></target>
</trans-unit>
<trans-unit id="392">
<source xml:lang="en">Example</source>
<seg-source><mrk mid="0" mtype="seg">Example</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Example</mrk></target>
</trans-unit>
<trans-unit id="393">
<source xml:lang="en">Option 1, using offset parameter</source>
<seg-source><mrk mid="0" mtype="seg">Option 1, using offset parameter</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Option 1, using offset parameter</mrk></target>
</trans-unit>
<trans-unit id="394">
<source xml:lang="en">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></source>
<seg-source><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></target>
</trans-unit>
<trans-unit id="395">
<source xml:lang="en">(?i)&lt;test>(.*?)&lt;/test></source>
<seg-source><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></target>
</trans-unit>
<trans-unit id="396">
<source xml:lang="en">RegExp Test with Option 1 -</source>
<seg-source><mrk mid="0" mtype="seg">RegExp Test with Option 1 -</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RegExp Test with Option 1 -</mrk></target>
</trans-unit>
<trans-unit id="397">
<source xml:lang="en">Option 2, single return, php/preg_match() style</source>
<seg-source><mrk mid="0" mtype="seg">Option 2, single return, php/preg_match() style</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Option 2, single return, php/preg_match() style</mrk></target>
</trans-unit>
<trans-unit id="398">
<source xml:lang="en">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></source>
<seg-source><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></target>
</trans-unit>
<trans-unit id="399">
<source xml:lang="en">(?i)&lt;test>(.*?)&lt;/test></source>
<seg-source><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></target>
</trans-unit>
<trans-unit id="400">
<source xml:lang="en">RegExp Test with Option 2 -</source>
<seg-source><mrk mid="0" mtype="seg">RegExp Test with Option 2 -</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RegExp Test with Option 2 -</mrk></target>
</trans-unit>
<trans-unit id="401">
<source xml:lang="en">Option 3, global return, old AutoIt style</source>
<seg-source><mrk mid="0" mtype="seg">Option 3, global return, old AutoIt style</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Option 3, global return, old AutoIt style</mrk></target>
</trans-unit>
<trans-unit id="402">
<source xml:lang="en">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></source>
<seg-source><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">&lt;test>a&lt;/test> &lt;test>b&lt;/test> &lt;test>c&lt;/Test></mrk></target>
</trans-unit>
<trans-unit id="403">
<source xml:lang="en">(?i)&lt;test>(.*?)&lt;/test></source>
<seg-source><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">(?i)&lt;test>(.*?)&lt;/test></mrk></target>
</trans-unit>
<trans-unit id="404">
<source xml:lang="en">RegExp Test with Option 3 -</source>
<seg-source><mrk mid="0" mtype="seg">RegExp Test with Option 3 -</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RegExp Test with Option 3 -</mrk></target>
</trans-unit>
<trans-unit id="405">
<source xml:lang="en">Option 4, global return, php/preg_match_all() style</source>
<seg-source><mrk mid="0" mtype="seg">Option 4, global return, php/preg_match_all() style</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Option 4, global return, php/preg_match_all() style</mrk></target>
</trans-unit>
<trans-unit id="406">
<source xml:lang="en">F1oF2oF3o</source>
<seg-source><mrk mid="0" mtype="seg">F1oF2oF3o</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">F1oF2oF3o</mrk></target>
</trans-unit>
<trans-unit id="407">
<source xml:lang="en">(F.o)*?</source>
<seg-source><mrk mid="0" mtype="seg">(F.o)*?</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">(F.o)*?</mrk></target>
</trans-unit>
<trans-unit id="408">
<source xml:lang="en">RegExp Test with Option 4 -</source>
<seg-source><mrk mid="0" mtype="seg">RegExp Test with Option 4 -</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RegExp Test with Option 4 -</mrk></target>
</trans-unit>
<trans-unit id="409">
<source xml:lang="en">,</source>
<seg-source><mrk mid="0" mtype="seg">,</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">,</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
